<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hero never die</title>
  
  <subtitle>码农界的一股清流</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zbwblog.com/"/>
  <updated>2019-10-02T14:45:19.656Z</updated>
  <id>http://www.zbwblog.com/</id>
  
  <author>
    <name>无畏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端模块化</title>
    <link href="http://www.zbwblog.com/2019/10/02/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://www.zbwblog.com/2019/10/02/前端模块化/</id>
    <published>2019-10-02T14:37:00.000Z</published>
    <updated>2019-10-02T14:45:19.656Z</updated>
    
    <content type="html"><![CDATA[<p>整理学习前端模块概念及模块化规范。<br><a id="more"></a><br><!-- toc --></p><h2 id="模块的基本要求"><a href="#模块的基本要求" class="headerlink" title="模块的基本要求"></a>模块的基本要求</h2><ol><li>隐藏模块内部实现，使模块的使用者无需关注模块内部实现的细节</li><li>对外定义模块的访问接口，通过接口可以调用模块功能</li></ol><h2 id="模块接口"><a href="#模块接口" class="headerlink" title="模块接口"></a>模块接口</h2><p>模块接口通常包含一组变量和函数，创建接口最简单的方式是使用js对象</p><h2 id="四种模块方式实现"><a href="#四种模块方式实现" class="headerlink" title="四种模块方式实现"></a>四种模块方式实现</h2><p>目标：实现一个util模块，外部可以调用模块的add工具方法</p><h3 id="函数模块"><a href="#函数模块" class="headerlink" title="函数模块"></a>函数模块</h3><p>使用自执行的匿名函数（IIFE）实现隐藏内部实现要求</p><p>使用闭包、对象实现对外定义模块的访问接口要求</p><p>扩展时，需要调用一个IIFE，改函数接收需要扩展的模块变量作为参数</p><p><img src="/assets/images/函数模块.png" alt="函数模块"></p><p>函数模块缺点</p><ol><li>通过模块扩展无法共享模块的私有变量</li><li>当我们开始创建模块化应用时，模块本身尝尝依赖其他模块的功能，然而函数模块模块无法实现这些依赖关系</li></ol><h3 id="AMD-和-CommonJs"><a href="#AMD-和-CommonJs" class="headerlink" title="AMD 和 CommonJs"></a>AMD 和 CommonJs</h3><p>为了弥补函数模块的缺点，AMD 与 CommonJs两大<strong>标准</strong>产生，并相互竞争。</p><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><ol><li>ADM最流行的实现是<strong>RequireJs</strong></li><li>设计理念是明确基于浏览器</li><li>自动处理依赖，无需考虑模块引入问题</li><li>异步加载依赖模块，避免阻塞 （解决前端应用场景中向服务器请求依赖模块文件问题）</li><li>所有依赖模块加载完毕后，调用模块的工厂函数，并传入依赖模块</li><li>在同一个文件中可以定义多个模块</li><li>对外提供模块访问接口的实现方式与函数模块一致</li></ol><p><img src="/assets/images/AMD模块.png" alt="AMD模块"></p><h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h4><ol><li>每个文件，只能定义一个模块</li><li>module.exports 作为模块的公共接口</li><li>可以引入依赖模块，依赖同步加载 （由于服务器端常读磁盘文件，速度较快，与http请求速度不在同一个量级，所以使用同步加载）</li><li>变量可以定义在文件的顶部，虽然是顶部，但仍属于模块内部的局部变量</li><li>nodeJs 默认的模块标准</li></ol><p>CommonJs缺点</p><p>不显示的支持浏览器</p><p><img src="/assets/images/CommonJs.png" alt="CommonJs"></p><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>在模块规范百家争鸣下，为实现统一的模块化标准，UMD产生了。</p><p>先判断运行环境是否支持cjs，然后判断是否支持amd，如果都不支持，则使用函数模块方式（IIFE），生成一个全局变量。</p><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>主要思想：必须显式的使用标识符导出模块，才能从外部访问模块</p><p>虽然变量可以定义在模块顶部，但是仍然只能在模块内部访问变量</p><p>目前浏览器尚未支持ES6模块，如果现在需要ES6模块，需要对代码进行编译，可以使用Traceur 或 babel 或 typescript</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td>export const add = (a, b) =&gt; a + b</td><td>导出变量</td></tr><tr><td>export function add (a, b) { return a + b}</td><td>导出函数</td></tr><tr><td>export class add {}</td><td>导出类</td></tr><tr><td>export default class add {}</td><td>导出默认类</td></tr><tr><td>export default function() {}</td><td>导出默认函数</td></tr><tr><td>export default add</td><td>导出默认对象</td></tr><tr><td>export { add, delete }</td><td>导出存在的变量  命名导出</td></tr><tr><td>export { add as add1 }</td><td>使用别名导出变量</td></tr><tr><td>export default function () {} export { add }</td><td>同时使用默认导出和命名导出</td></tr></tbody></table><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td>import add from ‘./add’</td><td>导入默认导出</td></tr><tr><td>import { add } from ‘./add’</td><td>导入命名导出</td></tr><tr><td>import * as all from ‘./add’</td><td>导入模块中声明的全部导出</td></tr><tr><td>import add, { add } from ‘./add’</td><td>同时导入默认导出和命名导出</td></tr><tr><td>import { add as add1 } from ‘./add’</td><td>通过别名导入模块中声明的全部导出，到本模块依赖两个不同模块内容，并且依赖内容命名一致时使用</td></tr></tbody></table><p><img src="/assets/images/es6模块.png" alt="es6模块"></p><h4 id="主文件进行模块管理"><a href="#主文件进行模块管理" class="headerlink" title="主文件进行模块管理"></a>主文件进行模块管理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/index.js</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'shared/util'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./lang'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./env'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./options'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./debug'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./props'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./error'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./next-tick'</span></span><br><span class="line"><span class="keyword">export</span> &#123; defineReactive &#125; <span class="keyword">from</span> <span class="string">'../observer/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">'./util/index.js'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理学习前端模块概念及模块化规范。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="规范" scheme="http://www.zbwblog.com/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="js" scheme="http://www.zbwblog.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>使用postMessage+iframe开发插件式服务</title>
    <link href="http://www.zbwblog.com/2019/10/01/%E4%BD%BF%E7%94%A8postMessage+iframe%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6%E5%BC%8F%E6%9C%8D%E5%8A%A1/"/>
    <id>http://www.zbwblog.com/2019/10/01/使用postMessage+iframe开发插件式服务/</id>
    <published>2019-10-01T04:45:00.000Z</published>
    <updated>2019-10-01T04:56:46.626Z</updated>
    
    <content type="html"><![CDATA[<p>与iframe通信的那些事儿。<br><a id="more"></a><br><!-- toc --></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>调用方</strong>：调用iframe服务的一方</p><p><strong>服务方</strong>：在iframe中，开发页面服务的一方</p><h2 id="调用方"><a href="#调用方" class="headerlink" title="调用方"></a>调用方</h2><ol><li><p>调用方使用url传参方式对iframe项目进行初始化<br><img src="/assets/images/iframe-message0.png" alt="调用方使用url传参方式对iframe项目进行初始化"></p></li><li><p>监听服务方派发出的事件<br><img src="/assets/images/iframe-message1.png" alt="监听服务方派发出的事件"></p></li><li><p>调用方通过postMessage向服务方传递数据<br><img src="/assets/images/iframe-message2.png" alt="调用方使用url传参方式对iframe项目进行初始化"></p></li></ol><h2 id="服务方"><a href="#服务方" class="headerlink" title="服务方"></a>服务方</h2><ol><li><p>服务方通过url获取参数，对项目进行初始化<br><img src="/assets/images/iframe-message3.png" alt="调用方使用url传参方式对iframe项目进行初始化"></p></li><li><p>服务方派发消息给调用方<br><img src="/assets/images/iframe-message4.png" alt="调用方使用url传参方式对iframe项目进行初始化"></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与iframe通信的那些事儿。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="iframe" scheme="http://www.zbwblog.com/tags/iframe/"/>
    
      <category term="postMessage" scheme="http://www.zbwblog.com/tags/postMessage/"/>
    
      <category term="插件" scheme="http://www.zbwblog.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>性能优化—http</title>
    <link href="http://www.zbwblog.com/2019/10/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94http/"/>
    <id>http://www.zbwblog.com/2019/10/01/性能优化——http/</id>
    <published>2019-10-01T03:59:21.000Z</published>
    <updated>2019-10-01T04:34:19.095Z</updated>
    
    <content type="html"><![CDATA[<p>介绍压缩、缓存是如何实现的。<br><a id="more"></a><br><!-- toc --></p><h2 id="http主要优化方式"><a href="#http主要优化方式" class="headerlink" title="http主要优化方式"></a>http主要优化方式</h2><ol><li><strong>压缩</strong></li><li><strong>缓存</strong></li></ol><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><h3 id="http压缩与uglify压缩区别"><a href="#http压缩与uglify压缩区别" class="headerlink" title="http压缩与uglify压缩区别"></a>http压缩与uglify压缩区别</h3><ol><li><p>uglify压缩js代码中的空格、空行，混淆代码指将过长变量名统一替换成简单字符</p></li><li><p>http压缩是将文件内容中重复的部分进行压缩，如html中重复的标签名，重复的部分越多，压缩质量越高</p><p>视频，音频相关的文件，压缩质量很低</p><p>压缩完是可以解压的，而不是删除内容</p></li></ol><h3 id="压缩流程"><a href="#压缩流程" class="headerlink" title="压缩流程"></a>压缩流程</h3><ol><li><p>客户端发出http请求文件时，请求头中的 <code>Accept-Encoding</code> 字段告知服务器，自身支持哪种压缩格式</p><p>例：<code>Accept-Encoding: br;q=1.0, gzip;q=0.8, *;q=0.1</code></p><p>q是权重 1最高</p></li><li><p>服务器收到请求后，根据请求头中的 <code>Accept-Encoding</code>  字段知道了客户端浏览器支持的压缩格式，如果有压缩，没有就不压缩。压缩完成后，写入文件，返回给客户端浏览器</p><p>并在 <code>response Header</code> 中返回 <code>content-encoding</code> 字段告知浏览器，文件是以什么样的格式进行压缩的，否则浏览器无法正确解析压缩过后的文件，会出现乱码</p><p>例：<code>content-encoding: gzip</code></p><p>node压缩格式一般是 <code>gzip、 deflate</code></p></li></ol><h3 id="压缩原理"><a href="#压缩原理" class="headerlink" title="压缩原理"></a>压缩原理</h3><p>压缩功能实现是使用node专用于做压缩的zlib模块，zlib模块压缩方式：</p><ol><li><p>同步压缩：等文件所有内容压缩完，在返回给客户端</p></li><li><p>流式压缩：一边压缩一边返回</p><p>实际上是借助<strong>转换流</strong>的概念，将目标文件读取出来，经过转换流压缩，在返回给客户端。</p><p><code>可读流.pipe(zlib.createGzip()).pipe(可写流)</code></p></li></ol><h3 id="压缩实战"><a href="#压缩实战" class="headerlink" title="压缩实战"></a>压缩实战</h3><ol><li>webpack 的 devServer 中的 <code>compress</code> 属性</li></ol><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存指，客户端浏览器请求服务器获取到资源后，同时会将资源复制一份缓存至本地硬盘中的一个文件内。</p><p>再次请求服务器同一资源时，会被服务器返回的信息告知从自己的缓存文件夹中获取即可。</p><p>这个交互过程实现了资源的缓存</p><h3 id="缓存的方式"><a href="#缓存的方式" class="headerlink" title="缓存的方式"></a>缓存的方式</h3><ol><li><strong>强制缓存</strong></li><li><strong>对比缓存（协商缓存）</strong></li><li><strong>指纹缓存</strong></li></ol><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><h4 id="什么是强制缓存"><a href="#什么是强制缓存" class="headerlink" title="什么是强制缓存"></a>什么是强制缓存</h4><p>客户端发起请求，服务器在返回资源的同时，在<strong>响应中</strong>设置 <code>Cache-Control</code> 或者 <code>Expires</code> 告知客户端浏览器：<strong>10秒之内</strong>、或在<strong>规定日期之前</strong>不要再找我了，从你的缓存文件夹中取！</p><p>走强制缓存时，响应状态码为200</p><h4 id="Cache-Control-与-Expires-区别"><a href="#Cache-Control-与-Expires-区别" class="headerlink" title="Cache-Control 与 Expires 区别"></a>Cache-Control 与 Expires 区别</h4><ol><li><p>写法不同</p><p><code>Cache-Control: max-age=10</code></p><p><code>Expires: Expires: Wed, 21 Oct 2015 07:28:00 GMT</code></p></li><li><p>单位不同</p><p>Cache-Control 单位是秒，是<strong>相对时间</strong>，表示多少秒之后</p><p>Expires 单位是UTC，也就是我们所说的<strong>格林威治时间</strong>，指的是time中的<strong>世界时间标准</strong>。是绝对时间，表示过期时间是什么时候。</p></li><li><p>权重不同</p><p>因为Expires是老版本设置， 设置Cache-Control 会覆盖掉 Expires</p></li></ol><h4 id="强制缓存缺点"><a href="#强制缓存缺点" class="headerlink" title="强制缓存缺点"></a>强制缓存缺点</h4><p>服务器文件更新之后，在没有超过规定时间时，客户端浏览器仍会走缓存，访问旧文件</p><h3 id="对比缓存（协商缓存）304"><a href="#对比缓存（协商缓存）304" class="headerlink" title="对比缓存（协商缓存）304"></a>对比缓存（协商缓存）304</h3><h4 id="什么是对比缓存"><a href="#什么是对比缓存" class="headerlink" title="什么是对比缓存"></a>什么是对比缓存</h4><p>客户端请求第一次时，服务器在response中设置 <code>Last-Modified</code> ，告之客户端这个文件最新修改时间。</p><p>客户端下次再请求时，在request中会携带 <code>If-Modified-Since</code> 这个时间戳标识，服务器比较标识，如果标识不同，证明后来又被修改过，返回新文件。否则告知客户端：文件没有变化，从缓存中去取吧。</p><p>走对比缓存时，<strong>响应状态码为304</strong></p><h4 id="对比缓存缺点"><a href="#对比缓存缺点" class="headerlink" title="对比缓存缺点"></a>对比缓存缺点</h4><ol><li>反复操作文件，虽然文件内容没变，但是最后修改时间改了。客户端不会走缓存。</li><li>cdn分发时间不同，会导致得到不一样的结果</li></ol><h3 id="指纹缓存"><a href="#指纹缓存" class="headerlink" title="指纹缓存"></a>指纹缓存</h3><h4 id="什么是指纹缓存"><a href="#什么是指纹缓存" class="headerlink" title="什么是指纹缓存"></a>什么是指纹缓存</h4><p>首次接到请求后，摘要/加盐文件部分内容，生成唯一key，名为 <code>Etag</code> 传给客户端。</p><p>客户端下次再请求同一文件时，在request中加入请求头 <code>If-None-Match</code></p><p>服务器端收到后作比较，更加准确的判断文件是否被修改过，后续同对比缓存</p><p>例</p><p><code>ETag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</code></p><p><code>If-None-Match: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</code></p><h4 id="什么是MD5"><a href="#什么是MD5" class="headerlink" title="什么是MD5"></a>什么是MD5</h4><p>MD5是一种信息摘要算法，摘取文件部分内容。</p><p>MD5本来也不是作加密使用，而是用来<strong>校验数据的完整性</strong>。</p><p>MD5不算是加密算法，因为摘要不代表全部内容，不可解密，不可反推，就是无论多大数据，经过算法运算后都是<strong>生成固定长度</strong>的数据。</p><p>相同的内容摘要的结果相同。有一点不同，摘要的结果完全不同。</p><h4 id="使用MD5"><a href="#使用MD5" class="headerlink" title="使用MD5"></a>使用MD5</h4><p><code>Crypto.createHash(&#39;md5&#39;).update(&#39;文件部分内容&#39; + random() ).digest(&#39;base64&#39;)</code></p><p>由于MD5大家都知道，很容易被猜到，所以在摘要时加一个随机数。</p><h4 id="什么是加盐"><a href="#什么是加盐" class="headerlink" title="什么是加盐"></a>什么是加盐</h4><p>使用 <code>sha1</code> <code>sha256</code> 这种加密算法，流程同MD5相同</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>开启所有类型缓存，只要有一个失效，就算失效。</p><p>先<strong>强制缓存（200）</strong>——再对比缓存和指纹缓存（两者有一个失效就算过期）</p><p>那么<strong>问题来了</strong>，这样设置时，在强制缓存下，缓存没过期时，服务器端更改了文件，客户端不一样拿不到最新的文件吗。</p><p>我们所说的缓存多用于静态资源和图片（static文件夹），对于经常改编的js逻辑，在正式生产环境打包时，会生成不同的hash值。</p><p>由于index.html文件不会被缓存，所以该文件中引入的js文件即时打包生成带有最新的hash值的js。所以请求会指向新的URI，不会走缓存。</p><h3 id="常见问题总结"><a href="#常见问题总结" class="headerlink" title="常见问题总结"></a>常见问题总结</h3><ol><li><p>缓存设置操作只能在服务器端进行，客户端浏览器能做什么？</p><p>前端并不能做什么。缓存这件事，让服务器端去搞。</p></li><li>首页index.html即使没有加hash戳也是不会被缓存的，防止出现断网时仍能访问页面的情况</li><li>浏览器network上，有一个小按钮，可以禁用所有缓存</li><li>关于 <code>Cache-Control</code> 响应头的值，当服务器设置为 <code>no-cache</code> 时，代表每次请求会都访问服务器，但是也会走缓存。当值为 <code>no-store</code> 才表示所有的请求，都不会走缓存</li><li>在进行指纹缓存时，node服务器端多使用 <code>Crypto</code> 第三方模块</li><li><p>服务器端设置各种响应头标识（<code>Last-Modified等</code>）当前文件最新状态，那客户端浏览器第二次发给服务器时，需要手动把这个标识设置到请求头吗？</p><p>不需要，浏览器会携带</p></li></ol><p><img src="/assets/images/性能优化—http.png" alt="http"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍压缩、缓存是如何实现的。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="http" scheme="http://www.zbwblog.com/tags/http/"/>
    
      <category term="性能优化" scheme="http://www.zbwblog.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="压缩" scheme="http://www.zbwblog.com/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="缓存" scheme="http://www.zbwblog.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>图片资源相关</title>
    <link href="http://www.zbwblog.com/2019/09/28/%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E7%9B%B8%E5%85%B3/"/>
    <id>http://www.zbwblog.com/2019/09/28/图片资源相关/</id>
    <published>2019-09-28T05:33:00.000Z</published>
    <updated>2019-10-01T04:56:46.636Z</updated>
    
    <content type="html"><![CDATA[<p>介绍图片文件资源。<br>实际开发中，如何正确处理图片资源。<br><a id="more"></a><br><!-- toc --></p><h2 id="与图片相关的数据类型有哪些"><a href="#与图片相关的数据类型有哪些" class="headerlink" title="与图片相关的数据类型有哪些"></a>与图片相关的数据类型有哪些</h2><ol><li>image对象（js）=&gt; appendTo Body =&gt; img元素（dom）</li><li>dataUrl（base64、url）</li><li>file(基于blob)文件对象</li><li>canvas对象</li></ol><h2 id="图片各种数据类型间转换"><a href="#图片各种数据类型间转换" class="headerlink" title="图片各种数据类型间转换"></a>图片各种数据类型间转换</h2><p><img src="/assets/images/各种图片数据类型互转.png" alt="环境区分"></p><h2 id="src属性值可以是哪些"><a href="#src属性值可以是哪些" class="headerlink" title="src属性值可以是哪些"></a>src属性值可以是哪些</h2><ol><li>url地址</li><li>base64</li></ol><h2 id="获取图片宽高等数据"><a href="#获取图片宽高等数据" class="headerlink" title="获取图片宽高等数据"></a>获取图片宽高等数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片对象读取完毕后即可获取图片相关属性</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> width = <span class="keyword">this</span>.width</span><br><span class="line">  <span class="keyword">const</span> height = <span class="keyword">this</span>.height</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">'xxxxxxxx'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍图片文件资源。&lt;br&gt;实际开发中，如何正确处理图片资源。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="图片" scheme="http://www.zbwblog.com/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="文件资源" scheme="http://www.zbwblog.com/tags/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>使用vue-cli3</title>
    <link href="http://www.zbwblog.com/2019/09/28/%E4%BD%BF%E7%94%A8vue-cli3/"/>
    <id>http://www.zbwblog.com/2019/09/28/使用vue-cli3/</id>
    <published>2019-09-28T04:33:00.000Z</published>
    <updated>2019-10-01T04:58:29.203Z</updated>
    
    <content type="html"><![CDATA[<p>介绍vue-cli3在常见场景下的使用。<br><a id="more"></a><br><!-- toc --></p><h2 id="修改webpack配置"><a href="#修改webpack配置" class="headerlink" title="修改webpack配置"></a>修改webpack配置</h2><h3 id="chainWebpack选项"><a href="#chainWebpack选项" class="headerlink" title="chainWebpack选项"></a>chainWebpack选项</h3><p>chainWebpack 配置项允许我们更细粒度的控制 webpack 的内部配置，其集成的是 webpack-chain 这一插件，该插件可以让我们能够使用链式操作来修改配置</p><h3 id="configureWebpack选项"><a href="#configureWebpack选项" class="headerlink" title="configureWebpack选项"></a>configureWebpack选项</h3><p>configureWebpack 更倾向于整体替换和修改，该选项可以是一个对象或者函数。</p><p>当为对象时，实际上使用 <code>webpack-merge</code> 插件与原有配置进行合并。</p><p>当为函数时，可以直接使用其 config 参数来修改 webpack 中的配置。此时该函数也可以返回一个对象，与原有配置进行合并操作。</p><h2 id="生产环境sourceMap功能"><a href="#生产环境sourceMap功能" class="headerlink" title="生产环境sourceMap功能"></a>生产环境sourceMap功能</h2><p><code>productionSourceMap</code> 控制生产环境是否开启 <code>sourceMap</code> 功能。开启后，在生产环境中，代码报错时，易于调试，同时会暴露应用源代码</p><h2 id="为本项目增加二级目录"><a href="#为本项目增加二级目录" class="headerlink" title="为本项目增加二级目录"></a>为本项目增加二级目录</h2><p>如果你想要将项目地址加一个二级目录，比如：<code>http://localhost:8080/vue/</code>，那么我们需要在 <code>vue.config.js</code> 里配置 <code>baseurl</code> 这一项。</p><p>其改变的其实是 webpack 配置文件中 output 的 publicPath 项，这时候你重启终端再次打开页面的时候我们首页的 url 就会变成带二级目录的形式。</p><h2 id="区分本地、开发、生产环境"><a href="#区分本地、开发、生产环境" class="headerlink" title="区分本地、开发、生产环境"></a>区分本地、开发、生产环境</h2><p>摘自：<a href="https://juejin.im/book/5b23a5aef265da59716fda09/section/5b291904f265da597f1c74ea" target="_blank" rel="noopener">掘金小册-vue项目搭建与开发入门</a></p><h3 id="通过在不同的环境下注入不同标识区分环境"><a href="#通过在不同的环境下注入不同标识区分环境" class="headerlink" title="通过在不同的环境下注入不同标识区分环境"></a>通过在不同的环境下注入不同标识区分环境</h3><p>我们可以在根目录下创建以下形式的文件进行不同环境下变量的配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.env                # 在所有的环境中被载入</span><br><span class="line">.env.local          # 在所有的环境中被载入，但会被 git 忽略</span><br><span class="line">.env.[mode]         # 只在指定的模式中被载入</span><br><span class="line">.env.[mode].local   # 只在指定的模式中被载入，但会被 git 忽略</span><br></pre></td></tr></table></figure><p>比如我们创建一个名为 .env.stage 的文件，该文件表明其只在 stage 环境下被加载，在这个文件中，我们可以配置如下键值对的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=stage</span><br><span class="line">VUE_APP_TITLE=stage mode</span><br></pre></td></tr></table></figure><p>这时候我们怎么在 vue.config.js 中访问这些变量呢？很简单，使用 process.env.[name] 进行访问就可以了，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// development（在终端输出）</span></span><br></pre></td></tr></table></figure><p>当你运行 yarn serve 命令后会发现输出的是 development，因为 vue-cli-service serve 命令默认设置的环境是 development，你需要修改 package.json 中的 serve 脚本的命令为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"serve"</span>: <span class="string">"vue-cli-service serve --mode stage"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>--mode stage</code> 其实就是修改了 webpack 4 中的 mode 配置项为 stage，同时其会读取对应 <code>.env.[model]</code> 文件下的配置，如果没找到对应配置文件，其会使用默认环境 development，同样 vue-cli-service build 会使用默认环境 production。</p><p>这时候如果你再创建一个 .env 的文件，再次配置重复的变量，但是值不同，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=staging</span><br><span class="line">VUE_APP_TITLE=staging mode</span><br><span class="line">VUE_APP_NAME=project</span><br></pre></td></tr></table></figure><p>因为 .env 文件会被所有环境加载，即公共配置，那么最终我们运行 vue-cli-service serve 打印出来的是哪个呢？答案是 stage，但是如果是 .env.stage.local 文件中配置成上方这样，答案便是 staging，所以 .env.[mode].local 会覆盖 .env.[mode] 下的相同配置。同理 .env.local 会覆盖 .env 下的相同配置。</p><p>由此可以得出结论，相同配置项的权重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.env.[mode].local &gt; .env.[mode] &gt; .env.local &gt; .env</span><br></pre></td></tr></table></figure><p>但是需要注意的是，除了相同配置项权重大的覆盖小的，不同配置项它们会进行合并操作，类似于 Javascript 中的 Object.assign 的用法。</p><h3 id="如何在客户端侧区分环境"><a href="#如何在客户端侧区分环境" class="headerlink" title="如何在客户端侧区分环境"></a>如何在客户端侧区分环境</h3><p>通过上述配置文件的创建，我们成功使用命令行的形式对项目环境进行了设置并可以自由切换，但是需要注意的是我们在 Vue 的前端代码中打印出的 process.env 与 vue.config.js 中输出的可能是不一样的，这需要普及一个知识点：webpack 通过 DefinePlugin 内置插件将 process.env 注入到客户端代码中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack 配置</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            <span class="string">'process.env'</span>: &#123;</span><br><span class="line">                NODE_ENV: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 vue-cli 3.x 封装的 webpack 配置中已经帮我们完成了这个功能，所以我们可以直接在客户端代码中打印出 process.env 的值，该对象可以包含多个键值对，也就是说可以注入多个值，但是经过 CLI 封装后仅支持注入环境配置文件中以 VUE_APP_ 开头的变量，而 NODE_ENV 和 BASE_URL 这两个特殊变量除外。比如我们在权重最高的 .env.stage.local 文件中写入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=stage2</span><br><span class="line">VUE_APP_TITLE=stage mode2</span><br><span class="line">NAME=vue</span><br></pre></td></tr></table></figure><p>然后我们尝试在 vue.config.js 中打印 process.env，终端输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    npm_config_ignore_scripts: <span class="string">''</span>,</span><br><span class="line">    npm_config_version_git_sign: <span class="string">''</span>,</span><br><span class="line">    npm_config_ignore_optional: <span class="string">''</span>,</span><br><span class="line">    npm_config_init_version: <span class="string">'1.0.0'</span>,</span><br><span class="line">    npm_package_dependencies_vue_router: <span class="string">'^3.0.1'</span>,</span><br><span class="line">    npm_config_version_tag_prefix: <span class="string">'v'</span>,</span><br><span class="line">    npm_node_execpath: <span class="string">'/usr/local/bin/node'</span>,</span><br><span class="line">    NODE_ENV: <span class="string">'stage2'</span>,</span><br><span class="line">    VUE_APP_TITLE: <span class="string">'stage mode2'</span>,</span><br><span class="line">    NAME: <span class="string">'vue'</span>,</span><br><span class="line">    BABEL_ENV: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出内容除了我们环境配置中的变量外还包含了很多 npm 的信息，但是我们在入口文件 main.js <strong>客户端侧代码</strong>中打印会发现输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"BASE_URL"</span>: <span class="string">"/vue/"</span>,</span><br><span class="line">    <span class="string">"NODE_ENV"</span>: <span class="string">"stage2"</span>,</span><br><span class="line">    <span class="string">"VUE_APP_TITLE"</span>: <span class="string">"stage mode2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见注入时过滤调了非 VUE_APP_ 开头的变量，其中多出的 BASE_URL 为你在 vue.config.js 设置的值，默认为 /，其在环境配置文件中设置无效。</p><p><img src="/assets/images/环境区分1.jpg" alt="环境区分"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍vue-cli3在常见场景下的使用。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="vue" scheme="http://www.zbwblog.com/tags/vue/"/>
    
      <category term="脚手架" scheme="http://www.zbwblog.com/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    
      <category term="vue-cli3" scheme="http://www.zbwblog.com/tags/vue-cli3/"/>
    
  </entry>
  
  <entry>
    <title>关于package.json配置项</title>
    <link href="http://www.zbwblog.com/2019/09/25/%E5%85%B3%E4%BA%8Epackage.json/"/>
    <id>http://www.zbwblog.com/2019/09/25/关于package.json/</id>
    <published>2019-09-25T14:11:00.000Z</published>
    <updated>2019-10-01T04:38:26.126Z</updated>
    
    <content type="html"><![CDATA[<p>解读package.json配置项。<br><a id="more"></a><br><!-- toc --></p><h2 id="browserslist配置项"><a href="#browserslist配置项" class="headerlink" title="browserslist配置项"></a>browserslist配置项</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>browserslist是package.json包描述文件中的一个配置项，用于配置浏览器类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"browserslist"</span>: [</span><br><span class="line">    <span class="string">"&gt; 1%"</span>, <span class="comment">// 表示包含所有使用率 &gt; 1% 的浏览器</span></span><br><span class="line">    <span class="string">"last 2 versions"</span>, <span class="comment">// 表示包含浏览器最新的两个版本</span></span><br><span class="line">    <span class="string">"not ie &lt;= 8"</span> <span class="comment">// 表示不包含 ie8 及以下版本</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="为什么会存在"><a href="#为什么会存在" class="headerlink" title="为什么会存在"></a>为什么会存在</h3><p>主要作用是用于在不同的前端工具之间共享目标浏览器和 Node.js 的版本</p><p>比如像 autoprefixer 这样的插件需要把你写的 css 样式适配不同的浏览器，那么这里要针对哪些浏览器呢，就是上面配置中所包含的。</p><p>而如果写在 autoprefixer 的配置中，那么会存在一个问题，万一其他第三方插件也需要浏览器的包含范围用于实现其特定的功能，那么就又得在其配置中设置一遍，这样就无法得以共用。所以在 package.json 中配置 browserslist 的属性使得所有工具都会自动找到目标浏览器。</p><p>当然，你也可以单独写在 .browserslistrc 的文件中：</p><p>至于它是如何去衡量浏览器的使用率和版本的，数据都是来源于 Can I Use。你也可以访问 browserl.ist/ 去搜索配置项所包含的浏览器列表，比如搜索 last 2 versions 会得到你想要的结果，或者在项目终端运行如下命令查看：</p><h3 id="有哪些应用场景"><a href="#有哪些应用场景" class="headerlink" title="有哪些应用场景"></a>有哪些应用场景</h3><p>autoprefixer、babel、postcss</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解读package.json配置项。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="node" scheme="http://www.zbwblog.com/tags/node/"/>
    
      <category term="npm" scheme="http://www.zbwblog.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>关于webpack配置常见问题</title>
    <link href="http://www.zbwblog.com/2019/09/24/%E5%85%B3%E4%BA%8Ewebpack%E9%85%8D%E7%BD%AE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://www.zbwblog.com/2019/09/24/关于webpack配置常见问题/</id>
    <published>2019-09-24T15:01:00.000Z</published>
    <updated>2019-10-01T04:59:21.040Z</updated>
    
    <content type="html"><![CDATA[<p>总结配置webpack时常见的问题。<br><a id="more"></a><br><!-- toc --></p><h2 id="源码暴露"><a href="#源码暴露" class="headerlink" title="源码暴露"></a>源码暴露</h2><p>项目发布上线后，在控制台source选项中的webpack://文件夹中可以看到项目源码问题</p><p><img src="/assets/images/源码暴露.jpg" alt="源码暴露"></p><p>解决方案</p><p>关闭webpack中的sourceMap功能，即 <code>devtool</code> 选项</p><p>vue-cli3中，则许关闭vue.config.js中的 <code>productionSourceMap</code> 配置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结配置webpack时常见的问题。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="自动化构建" scheme="http://www.zbwblog.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/"/>
    
      <category term="前端工程化" scheme="http://www.zbwblog.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="http://www.zbwblog.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue项目搭建</title>
    <link href="http://www.zbwblog.com/2019/09/24/vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.zbwblog.com/2019/09/24/vue项目搭建/</id>
    <published>2019-09-24T15:01:00.000Z</published>
    <updated>2019-10-01T04:56:46.638Z</updated>
    
    <content type="html"><![CDATA[<p>从0搭建一个vue项目，你需要知道哪些东西。<br><a id="more"></a><br><!-- toc --></p><h2 id="搭建模板"><a href="#搭建模板" class="headerlink" title="搭建模板"></a>搭建模板</h2><p><a href="https://juejin.im/book/5b23a5aef265da59716fda09" target="_blank" rel="noopener">掘金小册——Vue 项目构建与开发入门</a></p><p><img src="/assets/images/vue单页应用基础配置.jpg" alt="环境区分"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从0搭建一个vue项目，你需要知道哪些东西。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="vue" scheme="http://www.zbwblog.com/tags/vue/"/>
    
      <category term="项目架构" scheme="http://www.zbwblog.com/tags/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ajax交互数据格式</title>
    <link href="http://www.zbwblog.com/2019/09/23/ajax%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"/>
    <id>http://www.zbwblog.com/2019/09/23/ajax交互数据格式/</id>
    <published>2019-09-23T14:05:00.000Z</published>
    <updated>2019-10-01T04:33:32.726Z</updated>
    
    <content type="html"><![CDATA[<p>总结前后端常用数据交互格式。<br><a id="more"></a><br><!-- toc --></p><h2 id="表单格式"><a href="#表单格式" class="headerlink" title="表单格式"></a>表单格式</h2><p><code>content-type:application/x-www-form-urlencoded</code></p><p>格式为：<a href="mailto:`name=zbw&amp;sex=1&amp;email=569119225@qq.com" target="_blank" rel="noopener">`name=zbw&amp;sex=1&amp;email=569119225@qq.com</a>` 字符串</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'/api/entrance/login'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">'email=xxxx&amp;password=xxxxx&amp;verifyCode=344&amp;key=123'</span></span><br><span class="line"></span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"></span><br><span class="line">xhr.send(data)</span><br></pre></td></tr></table></figure><h2 id="formData格式"><a href="#formData格式" class="headerlink" title="formData格式"></a>formData格式</h2><p><code>content-type:multipart/form-data</code></p><p>一般用于传输文件、图片。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> FormData()</span><br><span class="line">data.append(<span class="string">'srcId'</span>, <span class="number">2</span>)</span><br><span class="line">data.append(<span class="string">'uId'</span>, uId)</span><br><span class="line">data.append(<span class="string">'envId'</span>, envId)</span><br><span class="line">data.append(<span class="string">'cntrId'</span>, cntrId)</span><br><span class="line">data.append(<span class="string">'dataJson'</span>, <span class="built_in">JSON</span>.stringify(dataJson))</span><br><span class="line"></span><br><span class="line">axios.post(</span><br><span class="line">  url,</span><br><span class="line">  data,</span><br><span class="line">  &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="json格式"><a href="#json格式" class="headerlink" title="json格式"></a>json格式</h2><p><code>content-type:application/json</code></p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">axios.post(</span><br><span class="line">  url,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'zbw'</span>,</span><br><span class="line">    sex: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结前后端常用数据交互格式。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="http" scheme="http://www.zbwblog.com/tags/http/"/>
    
      <category term="ajax" scheme="http://www.zbwblog.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>使用gulp构建一个模板项目</title>
    <link href="http://www.zbwblog.com/2019/09/22/%E4%BD%BF%E7%94%A8gulp%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE/"/>
    <id>http://www.zbwblog.com/2019/09/22/使用gulp构建一个模板项目/</id>
    <published>2019-09-22T15:49:00.000Z</published>
    <updated>2019-10-01T04:33:32.728Z</updated>
    
    <content type="html"><![CDATA[<p>使用gulp从0搭建一个简单的应用模板项目。<br>包括：压缩混淆js、处理es6语法、css预处理、解决跨域问题等。<br><a id="more"></a><br><!-- toc --></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>使用gulp从零构建一个登录页面</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><code>npm init -y</code></li><li><p><code>git init</code> 建立git仓库</p><p>设置 <code>.gitignore</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">.idea</span><br></pre></td></tr></table></figure></li><li><p>安装gulp</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --global gulp-cli</span><br><span class="line"></span><br><span class="line">npm i -D gulp</span><br></pre></td></tr></table></figure></li><li><p>创建一个简单的gulpfile</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; series, src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> src(<span class="string">'src/**/*.js'</span>)</span><br><span class="line">         .pipe(dest(<span class="string">'dist'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.default = series(jsTask);</span><br></pre></td></tr></table></figure></li></ol><h2 id="gulp命令"><a href="#gulp命令" class="headerlink" title="gulp命令"></a>gulp命令</h2><ol><li><p>查看帮助</p><p><code>gulp -h</code></p></li><li><p>查看所有任务</p><p><code>gulp --tasks</code></p></li><li><p>执行任务</p><p><code>gulp [任务名称]</code></p></li></ol><h2 id="gulp插件"><a href="#gulp插件" class="headerlink" title="gulp插件"></a>gulp插件</h2><h3 id="删除dist目录"><a href="#删除dist目录" class="headerlink" title="删除dist目录"></a>删除dist目录</h3><p><code>npm i -D del</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanTask</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">  del.sync(<span class="string">'dist'</span>)</span><br><span class="line">    done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩、混淆"><a href="#压缩、混淆" class="headerlink" title="压缩、混淆"></a>压缩、混淆</h3><p><code>npm i -D gulp-uglify</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"></span><br><span class="line"> .pipe(uglify())  <span class="comment">// 压缩、混淆</span></span><br></pre></td></tr></table></figure><h3 id="使用es6"><a href="#使用es6" class="headerlink" title="使用es6"></a>使用es6</h3><p><code>npm i -D @babel/core @babel/preset-env gulp-babel</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"></span><br><span class="line"> .pipe(babel(&#123;</span><br><span class="line">            presets: [<span class="string">'@babel/env'</span>]</span><br><span class="line">          &#125;))</span><br></pre></td></tr></table></figure><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p><code>npm i -D gulp-rename</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rename = <span class="built_in">require</span>(<span class="string">"gulp-rename"</span>);</span><br><span class="line"></span><br><span class="line">.pipe(rename(<span class="string">'zbw.js'</span>))</span><br><span class="line"></span><br><span class="line">.pipe(rename(<span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">    path.dirname += <span class="string">"/ciao"</span>;</span><br><span class="line">    path.basename += <span class="string">"-goodbye"</span>;</span><br><span class="line">    path.extname = <span class="string">".md"</span>;</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">.pipe(rename(&#123;</span><br><span class="line">    dirname: <span class="string">"main/text/ciao"</span>,</span><br><span class="line">    basename: <span class="string">"aloha"</span>,</span><br><span class="line">    prefix: <span class="string">"bonjour-"</span>,</span><br><span class="line">    suffix: <span class="string">"-hola"</span>,</span><br><span class="line">    extname: <span class="string">".md"</span></span><br><span class="line">  &#125;))</span><br></pre></td></tr></table></figure><h3 id="合并多文件，输出单一文件"><a href="#合并多文件，输出单一文件" class="headerlink" title="合并多文件，输出单一文件"></a>合并多文件，输出单一文件</h3><p><code>npm i -D gulp-concat</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> concat = <span class="built_in">require</span>(<span class="string">"gulp-concat"</span>);</span><br><span class="line"></span><br><span class="line"> .pipe(concat(<span class="string">'all.js'</span>))</span><br></pre></td></tr></table></figure><h3 id="处理css浏览器兼容性前缀"><a href="#处理css浏览器兼容性前缀" class="headerlink" title="处理css浏览器兼容性前缀"></a>处理css浏览器兼容性前缀</h3><p><code>npm i -D gulp-autoprefixer</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>);</span><br><span class="line"></span><br><span class="line"> .pipe(autoprefixer(&#123;</span><br><span class="line">            cascade: <span class="literal">false</span>,</span><br><span class="line">            remove: <span class="literal">false</span> <span class="comment">// 删除过时的prefixer</span></span><br><span class="line">          &#125;))</span><br><span class="line"></span><br><span class="line"> <span class="string">"browserslist"</span>: [</span><br><span class="line">    <span class="string">"last 2 version"</span>,</span><br><span class="line">    <span class="string">"&gt; 2%"</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h3 id="处理sass，编译压缩"><a href="#处理sass，编译压缩" class="headerlink" title="处理sass，编译压缩"></a>处理sass，编译压缩</h3><p><code>npm i -D gulp-sass</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"></span><br><span class="line">.pipe(sass(&#123;</span><br><span class="line">          outputStyle: <span class="string">'compressed'</span></span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure><h3 id="起一个本地服务，开始调接口吧"><a href="#起一个本地服务，开始调接口吧" class="headerlink" title="起一个本地服务，开始调接口吧"></a>起一个本地服务，开始调接口吧</h3><h4 id="browser-sync"><a href="#browser-sync" class="headerlink" title="browser-sync"></a>browser-sync</h4><p><code>npm i -D browser-sync</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browserSync = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>).create();</span><br><span class="line"><span class="keyword">const</span> reload = browserSync.reload;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在js任务后</span></span><br><span class="line">.pipe(dest(<span class="string">'./dist/js/'</span>))  <span class="comment">// 输出到根目录下dist文件夹</span></span><br><span class="line">.pipe(reload(&#123; <span class="attr">stream</span>: <span class="literal">true</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在css任务后</span></span><br><span class="line">.pipe(dest(<span class="string">'./dist'</span>))</span><br><span class="line">.pipe(reload(&#123; <span class="attr">stream</span>: <span class="literal">true</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">server</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">  browserSync.init(&#123;</span><br><span class="line">    server: &#123;</span><br><span class="line">      baseDir: <span class="string">'./'</span>  <span class="comment">// 指定根目录</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildTask = series([cleanTask, jsTask, cssTask, server, watcherTask])</span><br><span class="line"></span><br><span class="line">exports.default = buildTask;</span><br></pre></td></tr></table></figure><h4 id="gulp-connect-http-proxy-middleware"><a href="#gulp-connect-http-proxy-middleware" class="headerlink" title="gulp-connect + http-proxy-middleware"></a>gulp-connect + http-proxy-middleware</h4><p><code>gulp-connect</code> 用来起服务，配合 <code>http-proxy-middleware</code> 做代理，解决跨域问题</p><p><code>npm i -D gulp-connect http-proxy-middleware</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> connect = <span class="built_in">require</span>(<span class="string">'gulp-connect'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 起服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serverTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  connect.server(&#123;</span><br><span class="line">    root: <span class="string">'./dist'</span>,</span><br><span class="line">    port: <span class="number">8888</span>,</span><br><span class="line">    livereload: <span class="literal">true</span>,</span><br><span class="line">    middleware: <span class="function"><span class="keyword">function</span>(<span class="params">connect, opt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            proxy(<span class="string">'/api/'</span>,  &#123;</span><br><span class="line">                target: <span class="string">'https://devtk.aibeike.com'</span>,</span><br><span class="line">                changeOrigin:<span class="literal">true</span>,</span><br><span class="line">                pathRewrite: &#123;  <span class="comment">// 覆写路径</span></span><br><span class="line">                  <span class="string">'^/api/'</span>: <span class="string">''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 处理html任务</span></span><br><span class="line"><span class="comment"> * @returns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">'src/index.html'</span>)</span><br><span class="line">          .pipe(dest(<span class="string">'dist'</span>))</span><br><span class="line">          .pipe(connect.reload()) <span class="comment">// reload解决热加载问题，js和css资源同理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// serverTask任务和watcherTask任务要并行处理，否则执行到serverTask服务器启动后，任务就自动关闭了，热加载功能会丢失</span></span><br><span class="line"><span class="keyword">const</span> assetsTask = series(cleanTask, htmlTask, jsTask, cssTask, serverTask)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildTask = parallel(assetsTask, watcherTask)</span><br><span class="line"></span><br><span class="line">exports.default = buildTask;</span><br></pre></td></tr></table></figure><h4 id="browser-sync-与-gulp-connect-区别"><a href="#browser-sync-与-gulp-connect-区别" class="headerlink" title="browser-sync 与 gulp-connect 区别"></a>browser-sync 与 gulp-connect 区别</h4><p><code>browser-sync</code> 没有配合使用的代理插件，在解决跨域问题有些鸡肋</p><p><code>gulp-connect</code> 配合 <code>http-proxy-middleware</code> 使用可以很方便的解决跨域问题</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="return-和-done-有什么区别"><a href="#return-和-done-有什么区别" class="headerlink" title="return 和 done() 有什么区别"></a>return 和 done() 有什么区别</h3><p>return 是当返回promise时</p><p>done回调方法比较通用，比如热刷新reload时，return就不好使了</p><h3 id="为什么热刷新不好使"><a href="#为什么热刷新不好使" class="headerlink" title="为什么热刷新不好使"></a>为什么热刷新不好使</h3><p>这段代码不可以写成return，只能写成done</p><h3 id="做代理解决跨域问题时，遇到404问题"><a href="#做代理解决跨域问题时，遇到404问题" class="headerlink" title="做代理解决跨域问题时，遇到404问题"></a>做代理解决跨域问题时，遇到404问题</h3><p>遇到404的一种很常见的情况是，在proxy时，使用了 <code>/api</code> 作为请求接口的前缀链接，但是真正的接口地址中是不存在 <code>/api</code> 这样的路径的，此处需要使用 <code>pathRewrite</code> 覆写删除 <code>/api</code>。</p><p>同样的问题，参考资料：<a href="https://ymbo.github.io/2018/01/09/http-proxy-middleware%E9%85%8D%E5%90%88gulp%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/" target="_blank" rel="noopener">http-proxy-middleware配合gulp使用时的一些坑</a></p><h3 id="为什么引入第三方依赖包如jquery后，源代码找不到"><a href="#为什么引入第三方依赖包如jquery后，源代码找不到" class="headerlink" title="为什么引入第三方依赖包如jquery后，源代码找不到$"></a>为什么引入第三方依赖包如jquery后，源代码找不到$</h3><p>处理js资源时，src方法读取js文件的顺序是有要求的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 处理js任务</span></span><br><span class="line"><span class="comment"> * @returns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 读取src文件夹下所有js文件</span></span><br><span class="line">  <span class="comment">// 注意js文件打包引入的先后顺序，先导入lib，再导入应用代码</span></span><br><span class="line">  <span class="keyword">return</span> src([<span class="string">'src/lib/*.js'</span>, <span class="string">'src/js/*.js'</span>])</span><br><span class="line">          .pipe(babel(&#123; <span class="comment">// 编译es6</span></span><br><span class="line">            presets: [<span class="string">'@babel/env'</span>]</span><br><span class="line">          &#125;))</span><br><span class="line">          .pipe(uglify())  <span class="comment">// 压缩、混淆</span></span><br><span class="line">          .pipe(concat(<span class="string">'bundle.js'</span>)) <span class="comment">// 合并所有文件，输出all.js文件</span></span><br><span class="line">          <span class="comment">// .pipe(rename('bundle.js')) // 重命名为zbw.js</span></span><br><span class="line">          .pipe(dest(<span class="string">'./dist/js/'</span>))  <span class="comment">// 输出到根目录下dist文件夹</span></span><br><span class="line">          .pipe(connect.reload()) <span class="comment">// 热加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用gulp从0搭建一个简单的应用模板项目。&lt;br&gt;包括：压缩混淆js、处理es6语法、css预处理、解决跨域问题等。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="自动化构建" scheme="http://www.zbwblog.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/"/>
    
      <category term="前端工程化" scheme="http://www.zbwblog.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="gulp" scheme="http://www.zbwblog.com/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>图片上传阿里云后被自动旋转问题</title>
    <link href="http://www.zbwblog.com/2019/09/22/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%90%8E%E8%A2%AB%E6%97%8B%E8%BD%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://www.zbwblog.com/2019/09/22/图片上传后被旋转问题/</id>
    <published>2019-09-22T09:22:00.000Z</published>
    <updated>2019-10-01T04:56:46.630Z</updated>
    
    <content type="html"><![CDATA[<p>你知道EXIF是什么吗？<br><a id="more"></a><br><!-- toc --></p><!-- TOC --><ul><li><a href="#背景">背景</a></li><li><a href="#产生问题原因">产生问题原因</a></li><li><a href="#exif信息">EXIF信息</a></li><li><a href="#如何解决">如何解决</a><ul><li><a href="#方法一阿里云官方解决方案">方法一：阿里云官方解决方案</a></li><li><a href="#方法二修改图像元数据">方法二：修改图像元数据</a><ul><li><a href="#代码示例">代码示例</a></li></ul></li></ul></li><li><a href="#参考资料">参考资料</a></li></ul><!-- /TOC --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>开发移动端应用，使用原生 <code>file</code> 标签开发上传图片功能时，发现部分安卓手机，上传图片到阿里云成功后，使用返回的url回显插入到dom中时被莫名其妙地逆时针旋转了90度。</p><h2 id="产生问题原因"><a href="#产生问题原因" class="headerlink" title="产生问题原因"></a>产生问题原因</h2><p>一般通过手机或者倒置相机等方式拍出来的照片其实已经旋转，带有旋转参数。但是在图片查看器、浏览器中打开会对旋转参数的图片进行处理，所以我们看到的图片是正的。</p><h2 id="EXIF信息"><a href="#EXIF信息" class="headerlink" title="EXIF信息"></a>EXIF信息</h2><p>EXIF是专门为数码相机的照片设定，可以记录数码照片的属性信息和拍摄数据。</p><p>手机在拍照生成图片时，也会生成图片EXIF信息，我们称之为元数据。</p><p>所谓元数据，是用于描述数据的数据（信息）。</p><p>元数据中的 <code>Orientation</code> 属性即旋转参数，标识图片被旋转了多少度。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><h3 id="方法一：阿里云官方解决方案"><a href="#方法一：阿里云官方解决方案" class="headerlink" title="方法一：阿里云官方解决方案"></a>方法一：阿里云官方解决方案</h3><p><a href="https://help.aliyun.com/document_detail/44691.html?spm=a2c4g.11186623.6.1245.720c3091TC4Rv9" target="_blank" rel="noopener">阿里云官方解决方案</a></p><h3 id="方法二：修改图像元数据"><a href="#方法二：修改图像元数据" class="headerlink" title="方法二：修改图像元数据"></a>方法二：修改图像元数据</h3><p>解决思路是在上传阿里云逻辑之前，使用适配器模式，加一层适配逻辑。把被旋转过的file对象，转化成正常的file对象，再继续传阿里云。</p><ol><li>使用 <code>exif-js</code> 库获取图片元数据中的 <code>Orientation</code> 参数</li><li><p>根据参数判断图片是否需要旋转处理</p><p><code>Orientation</code> 值为 <code>undefined</code> 或 <code>0</code> 或 <code>1</code>  时，表示生成图片没有被旋转，因此不需要做额外的旋转处理</p></li><li><p>拿到 <code>file</code> 类型数据，使用 <code>fileReader</code> 转换成 <code>base64</code></p></li><li>在内存中创建image元素，读取 <code>base64</code> 生成img元素</li><li>在 <code>img</code> 元素 <code>onload</code> 时，使用 <code>canvas</code> 绘制图像</li><li>根据 <code>Orientation</code> 旋转 <code>canvas</code> 图层到正确的方向</li><li>将 <code>canvas</code> 对象转化为 <code>blob</code> 对象</li><li>将 <code>blob</code> 对象转化为 <code>file</code> 对象</li><li>回到上传阿里云的操作</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: zbw</span></span><br><span class="line"><span class="comment"> * @Date: 2019-09-19 18:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> EXIF <span class="keyword">from</span> <span class="string">'exif-js'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileToDataURL</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">      reader.onloadend = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        resolve(e.target.result)</span><br><span class="line">      &#125;</span><br><span class="line">      reader.readAsDataURL(file)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canvasResizetoFile</span> (<span class="params">canvas, quality = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    canvas.toBlob(<span class="function"><span class="keyword">function</span> (<span class="params">blob</span>) </span>&#123;</span><br><span class="line">      resolve(blob)</span><br><span class="line">    &#125;, <span class="string">'image/jpeg'</span>, quality)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blobToFile</span> (<span class="params">theBlob, fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">window</span>.File([theBlob], fileName, &#123;<span class="attr">type</span>: theBlob.type&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOrientation</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> orientation = <span class="number">0</span></span><br><span class="line">      EXIF.getData(file, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        orientation = EXIF.getTag(<span class="keyword">this</span>, <span class="string">'Orientation'</span>)</span><br><span class="line">        resolve(orientation)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理图片EXIF元数据</span></span><br><span class="line"><span class="comment"> * @param file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleEXIF</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 从图片元数据中读取旋转标识</span></span><br><span class="line">      <span class="keyword">const</span> orientation = <span class="keyword">await</span> getOrientation(file)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 正常未被旋转的图片orientation值</span></span><br><span class="line">      <span class="keyword">const</span> normalType = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">if</span> (!orientation || normalType.includes(<span class="built_in">Number</span>(orientation))) resolve(file)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果图片元数据中标识图片已经被旋转过了，则重置图片回未旋转状态，兼容同小米6等机型</span></span><br><span class="line">      <span class="keyword">const</span> base64Data = <span class="keyword">await</span> fileToDataURL(file)</span><br><span class="line">      <span class="keyword">let</span> imgTem = <span class="keyword">new</span> Image()</span><br><span class="line">      imgTem.onload = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">        <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">        <span class="keyword">const</span> width = imgTem.width</span><br><span class="line">        <span class="keyword">const</span> height = imgTem.height</span><br><span class="line">        <span class="keyword">const</span> isReverseSize = [<span class="number">6</span>, <span class="number">8</span>].includes(<span class="built_in">Number</span>.parseInt(orientation))</span><br><span class="line">        canvas.width = isReverseSize ? height : width</span><br><span class="line">        canvas.height = isReverseSize ? width : height</span><br><span class="line">        <span class="keyword">switch</span> (orientation) &#123;</span><br><span class="line">          <span class="comment">// 测试代码</span></span><br><span class="line">          <span class="comment">// case 1:</span></span><br><span class="line">          <span class="comment">// case undefined:</span></span><br><span class="line">          <span class="comment">//   ctx.drawImage(imgTem, 0, 0)</span></span><br><span class="line">          <span class="comment">//   break</span></span><br><span class="line">          <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="comment">// 图片顺时针旋转90°</span></span><br><span class="line">            ctx.rotate(<span class="built_in">Math</span>.PI / <span class="number">2</span>)</span><br><span class="line">            ctx.translate(<span class="number">0</span>, -height)</span><br><span class="line">            ctx.drawImage(imgTem, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="comment">// 图片顺时针旋转180°</span></span><br><span class="line">            ctx.rotate(<span class="built_in">Math</span>.PI)</span><br><span class="line">            ctx.translate(-width, -height)</span><br><span class="line">            ctx.drawImage(imgTem, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="comment">// 图片顺时针旋转270°</span></span><br><span class="line">            ctx.rotate(-<span class="built_in">Math</span>.PI / <span class="number">2</span>)</span><br><span class="line">            ctx.translate(-height, <span class="number">0</span>)</span><br><span class="line">            ctx.drawImage(imgTem, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> blob = <span class="keyword">await</span> canvasResizetoFile(canvas)</span><br><span class="line">        <span class="keyword">const</span> fileObj = blobToFile(blob, file.name)</span><br><span class="line">        resolve(fileObj)</span><br><span class="line">      &#125;</span><br><span class="line">      imgTem.src = base64Data</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  handleEXIF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![思维导图/assets/images/images/图片上传后被旋转问题.jpg)</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.mamicode.com/info-detail-2440485.html" target="_blank" rel="noopener">同一问题</a></li><li><a href="https://github.com/exif-js/exif-js" target="_blank" rel="noopener">exif-js</a></li><li><a href="http://code.ciaoca.com/javascript/exif-js/" target="_blank" rel="noopener">Exif.js 读取图像的元数据</a></li><li><a href="https://github.com/WangYuLue/image-conversion" target="_blank" rel="noopener">一个图片数据类型转换库</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" target="_blank" rel="noopener">fileReader-mdn</a></li><li><a href="https://www.cnblogs.com/lwxiao/p/10519617.html" target="_blank" rel="noopener">图片数据类型转换相关1</a></li><li><a href="https://www.jianshu.com/p/5b44c41adfe2" target="_blank" rel="noopener">图片数据类型转换相关2</a></li><li><a href="https://help.aliyun.com/knowledge_detail/39624.html" target="_blank" rel="noopener">如何解决正常原图处理之后为被旋转的问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你知道EXIF是什么吗？&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="阿里云" scheme="http://www.zbwblog.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="OSS上传" scheme="http://www.zbwblog.com/tags/OSS%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="图片" scheme="http://www.zbwblog.com/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="文件资源" scheme="http://www.zbwblog.com/tags/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90/"/>
    
      <category term="移动端" scheme="http://www.zbwblog.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="兼容问题" scheme="http://www.zbwblog.com/tags/%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端监控</title>
    <link href="http://www.zbwblog.com/2019/09/22/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    <id>http://www.zbwblog.com/2019/09/22/前端监控/</id>
    <published>2019-09-22T08:28:00.000Z</published>
    <updated>2019-10-01T05:00:02.439Z</updated>
    
    <content type="html"><![CDATA[<p>介绍前端监控在实际开发中的应用。<br><a id="more"></a><br><!-- toc --></p><h2 id="前端监控是什么"><a href="#前端监控是什么" class="headerlink" title="前端监控是什么"></a>前端监控是什么</h2><p>前端监控主要从以下三个方面监测网站运行时的健康程度。</p><ul><li>页面打开速度</li><li>页面稳定性（js报错）</li><li>外部服务调用成功率（api）</li></ul><h2 id="为什么要有前端监控"><a href="#为什么要有前端监控" class="headerlink" title="为什么要有前端监控"></a>为什么要有前端监控</h2><p>用户访问我们的业务时，整个访问过程大致可以分为三个阶段：页面生产时（Server 端状态）、页面加载时和页面运行时。</p><p>为了保证线上业务稳定运行，我们会在 Server 端对业务的运行状态进行各种监控。现有的 Server 端监控系统相对已经很成熟了，而页面加载和页面运行时的状态监控一直比较欠缺。例如：</p><p>无法第一时间获知用户访问我们的站点时遇到的错误；<br>各个国家、各个地区的用户访问我们站点的真实速度未知；<br>每个应用内有大量的异步数据调用，而它们的性能、成功率都是未知的。</p><h2 id="如何为网站设置前端监控"><a href="#如何为网站设置前端监控" class="headerlink" title="如何为网站设置前端监控"></a>如何为网站设置前端监控</h2><p>申请阿里云账号——购买服务，<a href="https://signin.aliyun.com/1796066747675887/login.htm" target="_blank" rel="noopener">登录</a><br><img src="/assets/images/前端监控1.jpg" alt="前端监控1"><br><img src="/assets/images/前端监控2.jpg" alt="前端监控2"><br><img src="/assets/images/前端监控3.jpg" alt="前端监控3"><br><img src="/assets/images/前端监控4.jpg" alt="前端监控4"></p><h2 id="使用原理"><a href="#使用原理" class="headerlink" title="使用原理"></a>使用原理</h2><p>购买服务后，添加应用，会为你生成一个唯一阿里云监控可以识别 <code>pid</code>, 在应用的js代码中，通过调用cdn公开接口的方式，将pid传给阿里云，阿里云自动帮助网站进行监控。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="环境区分"><a href="#环境区分" class="headerlink" title="环境区分"></a>环境区分</h3><p>我们需要的是线上真实用户的使用数据，因此在项目中，我们需要区分【本地、测试、dev】和【线上】环境，开发时生成两个pid。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  !(<span class="function"><span class="keyword">function</span>(<span class="params">c,b,d,a</span>)</span>&#123;</span><br><span class="line">    c[a]||(c[a]=&#123;&#125;);</span><br><span class="line">    c[a].config=&#123;<span class="attr">pid</span>:<span class="string">"honho8hw4v@29cc205fe71c7c8"</span>,<span class="attr">appType</span>:<span class="string">"web"</span>,<span class="attr">imgUrl</span>:<span class="string">"https://arms-retcode.aliyuncs.com/r.png?"</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>)</span><br><span class="line">    script.setAttribute(<span class="string">"crossorigin"</span>,<span class="string">""</span>)</span><br><span class="line">    script.setAttribute(<span class="string">"src"</span>, d)</span><br><span class="line">    <span class="keyword">const</span> firstChild = <span class="built_in">document</span>.body.firstChild</span><br><span class="line">    b.body.insertBefore(script, firstChild)</span><br><span class="line">  &#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>,<span class="string">"https://retcode.alicdn.com/retcode/bl.js"</span>,<span class="string">"__bl"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://help.aliyun.com/document_detail/58652.html?spm=a2c4g.11186623.6.617.d26b3ddfk41C9a" target="_blank" rel="noopener">阿里云前端监控</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍前端监控在实际开发中的应用。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="前端监控" scheme="http://www.zbwblog.com/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
      <category term="阿里云" scheme="http://www.zbwblog.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>vue实战技巧</title>
    <link href="http://www.zbwblog.com/2019/09/22/vue%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.zbwblog.com/2019/09/22/vue实战技巧/</id>
    <published>2019-09-22T07:52:00.000Z</published>
    <updated>2019-10-01T04:48:11.765Z</updated>
    
    <content type="html"><![CDATA[<p>在vue开发中你不知道的黑科技。<br><a id="more"></a><br><!-- toc --></p><h2 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h2><ol><li><p>是什么？</p><p>是vue中的一种依赖注入的概念api，由父级或祖先级向子级注入数据，子级接收，实现跨越无数层级组件间通讯。</p></li><li><p>为什么存在？</p><p>简化vue跨多层级组件通讯</p><p>开发独立组件时，代替 <code>vuex</code> 在顶层组件管理状态</p></li><li><p>注意</p><p>注入的数据并不是可响应的，这是刻意为之的，并且不能修改，会报错：避免直接改变注入的值（基本数据类型和引用数据类型的地址），因为只要提供的组件重新呈现，更改就会被覆盖。</p><p>但是！ <code>如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</code></p><p> 也就是说引用数据类型的属性是可以改变的，并且可以出发响应式变化，利用这一点，我们可以做很多事情。如利用入口模块向下注入核心数据对象，各子模块接收后粒度化拆分功能修改核心数据对象。</p><p><code>prop</code> 同理，<code>vue</code> 虽然宣扬单向数据流，但是这种类似于 <code>Angular</code> 数据双向绑定概念的操作，拆分核心对象数据到各个粒度化子组件修改，会让你的代码撸到爽到飞起。</p></li><li><p>在哪里可以使用</p><p>父级组件和子级组件产生了一种隐形的耦合关系，父级不知道最终将数据传给谁，子级不知道数据是从哪里获取到的，因此只建议在封闭度高的高阶组件和组件库中使用，不建议在应用代码中使用。</p><p>由于传入的基本类型数据不可响应，更推荐注入对象的形式。常用于初始化项目（组件）使用的配置，比如年部学科，这些东西一般不会发生变化，子组件又不定时需要。最重要的是，不依赖于vuex，因此成为开发独立插件组件的首选。</p></li><li><p>示例</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父级、祖先级组件</span></span><br><span class="line">provide() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    List: <span class="keyword">this</span>.List,</span><br><span class="line">    type: <span class="keyword">this</span>.type</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">inject: &#123;</span><br><span class="line"><span class="comment">// 类型</span></span><br><span class="line">  type: &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">// 列表</span></span><br><span class="line">  list: &#123;</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><ol><li><p>是什么</p><p>在某个位置，动态切换，加载不同的组件。</p></li><li><p>为什么存在</p><p>避免出现大量的 <code>v-if</code> , 更优雅处理业务逻辑。</p></li><li><p>注意</p><p>使用动态组件时，通常会重新创建不同的组件，但是当切换的是同一个组件的时候，如单选题组件和多选题组件，由于公用的是一个组件，vue内部会自动处理，不会再重新创建这个组件，不重新创建组件内的状态就无法清空，引发问题，此时需要加一个key作为唯一标识，保证组件重新创建。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> COMPONENT_CONFIG = &#123;</span><br><span class="line">  [QS_LOGIC_ID_MAP.SINGLE_CHOICE]: <span class="string">'Choice'</span>,</span><br><span class="line">  [QS_LOGIC_ID_MAP.MULTIPLE_CHOICE]: <span class="string">'Choice'</span>,</span><br><span class="line">  [QS_LOGIC_ID_MAP.FILL_BLANKS]: <span class="string">'FillBlank'</span>,</span><br><span class="line">  [QS_LOGIC_ID_MAP.RESOLVE_ANSWER]: <span class="string">'ResolveQs'</span>,</span><br><span class="line">  [QS_LOGIC_ID_MAP.COMPLEX]: <span class="string">'Complex'</span></span><br><span class="line">&#125;</span><br><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 当前逻辑题型</span></span><br><span class="line">  currentLogicId() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mainData.logicQuesTypeId</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当前组件</span></span><br><span class="line">  currentComponent() &#123;</span><br><span class="line">    <span class="keyword">return</span> COMPONENT_CONFIG[<span class="keyword">this</span>.currentLogicId]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&lt;component :is=<span class="string">"currentComponent"</span> :main-data=<span class="string">"mainData"</span> :key=<span class="string">"currentLogicId"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/component&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在哪里可以使用</p><p>如根据不同的题型id，切换不同的录题组件。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// currentComponent 是已注册组件的名字 或 一个组件的选项对象</span></span><br><span class="line">&lt;component :is=<span class="string">"currentComponent"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>   watch监听值/引用地址的变化</p><h3 id="immediate属性"><a href="#immediate属性" class="headerlink" title="immediate属性"></a>immediate属性</h3><ol><li><p>是什么？</p><p>让所监听数据初次赋值时就触发 <code>handler</code> ，而非纯异步监听：只有改变时才出发 <code>handler</code></p></li><li><p>为什么存在？</p><p>在一些特定的应用场景中，我们试图监听 <code>prop</code> ，而不仅仅是本组件中的状态，但父组件对子组件 <code>prop</code> 的初次赋值我们是监听不到的，所以 <code>immediate</code> 诞生了。</p></li><li><p>在哪里可以使用？</p><p>监听 <code>prop</code></p></li><li><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  mainData: &#123;</span><br><span class="line">    type: <span class="built_in">Object</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  mainData: &#123;</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 保证父组件初始化是对mainData（null）赋值后，子组件立即响应</span></span><br><span class="line">      immediate: <span class="literal">true</span>,</span><br><span class="line">        handler: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.$emit(<span class="string">'update'</span>, <span class="keyword">this</span>.mainData)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="关于控制组件状态"><a href="#关于控制组件状态" class="headerlink" title="关于控制组件状态"></a>关于控制组件状态</h2><ol><li><p>背景</p><p>我们经常说<strong>粒度化</strong>，指将<strong>复杂的功能拆解到不同子模块处理。</strong></p><p>经过使用vue了一段时间后，我们发现，由于父组件prop传进来的<strong>值/引用地址</strong>在<strong>无法在子组件中直接改变</strong>，于是我们会经常使用prop去初始化子组件中的状态/data，然后去<strong>随心所欲</strong>操作这份数据。</p><p>有<strong>两种方式</strong>，可以实现以上目标，一是直接在data中使用prop赋予默认值，二是在created钩子中，有一个初始化状态方法 <code>initStatus(slefData)</code> 。</p><p>我<strong>更推荐后者</strong>，因为也许有一天我们会遇到<strong>父组件需要重置子组件内部状态</strong>的场景，比如<strong>换一题</strong>这样的功能。</p><p><strong>换一题功能的两种解决方案</strong></p><ol><li>深度监听试题数据，试题数据发生变化后，重新调用子组件内的 <code>iniSelfData</code> 方法，自己刷新自己。但实际上这是消耗性能，并且不合理的操作。</li><li>考虑到<strong>性能**</strong>，我们既不希望一个庞大的组件<strong>重新创建</strong>，又不想要<strong>上一题留下的冗余的状态</strong>。那么此时我们就可以拿到子组件实例，在获取到下一题数据后，用新的核心数据，去重新调用子组件内部 <code>initSatus(slefData)</code> 方法，达到<strong>优雅更新子组件状态</strong>的目的。这种操作子组件对外提供一个<strong>接口</strong> 即 <code>initStatus</code> 方法，<strong>将重置组件状态的控制权交给父组件</strong>，这样的设计更加<strong>合情合理</strong>。</li></ol></li><li><p>注意</p><p>我知道很多时候我们需要在 <code>created</code> 钩子函数中异步调接口获取数据初始化。</p><p>但是<strong>千万不要</strong>写出 <code>async created(){}</code> 这样的钩子函数，因为它会将整<strong>个创建函数变成异步函数</strong>。</p><p>随之带来的是内部的 <code>initStatus(slefData)</code> 函数也变成了异步，但实际上我们需要的是同步。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">async</span> created() &#123;</span><br><span class="line">  <span class="comment">// 初始化组件内部，一些由用户操作而改变的状态</span></span><br><span class="line">  initStatus()</span><br><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> requestFn()</span><br><span class="line">  handlerData(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">async</span> getData() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> requestFn()</span><br><span class="line">&#125;</span><br><span class="line">created() &#123;</span><br><span class="line">  <span class="comment">// 初始化组件内部，一些由用户操作而改变的状态</span></span><br><span class="line">  initStatus()</span><br><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> getData()</span><br><span class="line">  handlerData(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>技巧</p><p><strong>重置组件状态</strong>：<code>Object.assign(this.$data, this.$options.data())</code></p></li></ol><h2 id="v-show-与-v-if"><a href="#v-show-与-v-if" class="headerlink" title="v-show 与 v-if"></a>v-show 与 v-if</h2><h3 id="v-show-与-v-if-有什么区别"><a href="#v-show-与-v-if-有什么区别" class="headerlink" title="v-show 与 v-if 有什么区别"></a>v-show 与 v-if 有什么区别</h3><p>   v-show 控制元素是否 <code>display: none</code> ，从样式的角度控制元素隐藏显示</p><p>   v-if 控制元素的dom是否存在，通过生成、移除dom元素控制元素隐藏显示</p><h3 id="v-show-与-v-if-实战技巧"><a href="#v-show-与-v-if-实战技巧" class="headerlink" title="v-show 与 v-if 实战技巧"></a>v-show 与 v-if 实战技巧</h3><ol><li><p>状态控制</p><p>场景：填写表单</p><p>当我们填写表单时，我们可以使用v-show省去写一系列的回显逻辑。</p><p>但与此同时，场景中可能存在取消操作，重置为初始状态，由于v-show不会重置组件、元素状态，所以我们可以在v-show为true时，先保留一份数据的备份，当用户点击取消时，我们使用备份的数据将状态还原。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在vue开发中你不知道的黑科技。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="vue" scheme="http://www.zbwblog.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>如何调试移动端应用</title>
    <link href="http://www.zbwblog.com/2019/09/08/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BA%94%E7%94%A8/"/>
    <id>http://www.zbwblog.com/2019/09/08/如何调试移动端应用/</id>
    <published>2019-09-08T05:04:00.000Z</published>
    <updated>2019-10-01T04:56:46.644Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如何调试安卓、ios应用程序。<br>介绍如何使用charles抓包。<br><a id="more"></a><br><!-- toc --></p><h2 id="如何在手机上访问开发环境的页面"><a href="#如何在手机上访问开发环境的页面" class="headerlink" title="如何在手机上访问开发环境的页面"></a>如何在手机上访问开发环境的页面</h2><ol><li>手机、电脑处于同一个无线网路中</li><li>通过草料二维码，将电脑端开发环境的页面地址（通过本机id访问）转化成二维码</li><li>手机扫码，通过浏览器打开</li></ol><h2 id="chrome控制台"><a href="#chrome控制台" class="headerlink" title="chrome控制台"></a>chrome控制台</h2><p>模拟调试移动端样式及部分交互事件</p><p><img src="/assets/images/调试移动端H5页面.jpg" alt="chrome控制台模拟移动端调试样式"></p><h2 id="调试ios手机"><a href="#调试ios手机" class="headerlink" title="调试ios手机"></a>调试ios手机</h2><ol><li>打开手机——设置——safari浏览器——高级——打开JavaScript、Web检查器</li><li>手机通过数据线连接电脑</li><li>打开电脑端safari浏览器——开发选项，即可显示手机名称标识，及当前手机safari所打开的页面</li></ol><h2 id="调试安卓手机"><a href="#调试安卓手机" class="headerlink" title="调试安卓手机"></a>调试安卓手机</h2><ol><li>打开安卓手机设置——开发者选项——打开开发者模式、打开usb调试</li><li>保证手机和电脑在同一网段内</li><li>在手机中的谷歌浏览器中使用ip的方式打开应用页面</li><li>电脑谷歌url输入 <code>chrome://inspect/#devices</code></li><li>勾选 <code>Discover USB devices</code></li><li>在下方可以看到目标手机的相关信息，选择目标网址下方的 <code>inspect</code> 开始调试</li></ol><p><strong>注意</strong>：谷歌浏览器的安卓手机调试页面，需要科学上网才可以打开，否则会出现黑屏的情况。</p><h2 id="调试嵌入式H5"><a href="#调试嵌入式H5" class="headerlink" title="调试嵌入式H5"></a>调试嵌入式H5</h2><ol><li><p><strong>charles抓包调试请求</strong><br><a href="https://www.jianshu.com/p/9d7c4cb14f2c" target="_blank" rel="noopener">Charles - 抓取https包内数据</a><br><a href="https://www.jianshu.com/p/0ed1ed8161f1" target="_blank" rel="noopener">利用 Charles Proxy 下载旧版本 iOS App【转】</a></p><p>ios手机在安装完证书之后，需要设置如下：<br>通用——描述文件<br>通用——关于本机——证书信任</p></li></ol><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.jianshu.com/p/ef94d0813b6b" target="_blank" rel="noopener">论：怎么调试H5手机页面</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍如何调试安卓、ios应用程序。&lt;br&gt;介绍如何使用charles抓包。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="移动端" scheme="http://www.zbwblog.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="调试" scheme="http://www.zbwblog.com/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>BEM规范</title>
    <link href="http://www.zbwblog.com/2019/09/08/BEM%E8%A7%84%E8%8C%83/"/>
    <id>http://www.zbwblog.com/2019/09/08/BEM规范/</id>
    <published>2019-09-08T03:46:00.000Z</published>
    <updated>2019-10-01T04:48:11.762Z</updated>
    
    <content type="html"><![CDATA[<p>强迫症患者还在为css命名发愁吗？<br><a id="more"></a><br><!-- toc --></p><p>CSS 的命名规范又叫做BEM规范，为的是结束混乱的命名方式，达到一个语义化的CSS命名方式。 BEM是三个单词的缩写：Block（块）代表更高级别的抽象或组件，Element（元素） Block的后代，以及Modifier（修饰） 不同状态的修饰符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form form--theme-xmas form--simple"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form__input"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"form__submit form__submit--disabled"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.form</span> &#123; &#125;</span><br><span class="line"><span class="selector-class">.form--theme-xmas</span> &#123; &#125;</span><br><span class="line"><span class="selector-class">.form--simple</span> &#123; &#125;</span><br><span class="line"><span class="selector-class">.form__input</span> &#123; &#125;</span><br><span class="line"><span class="selector-class">.form__submit</span> &#123; &#125;</span><br><span class="line"><span class="selector-class">.form__submit--disabled</span> &#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;强迫症患者还在为css命名发愁吗？&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="css" scheme="http://www.zbwblog.com/tags/css/"/>
    
      <category term="规范" scheme="http://www.zbwblog.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>客户端侧代码中区分环境</title>
    <link href="http://www.zbwblog.com/2019/08/08/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BE%A7%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%8C%BA%E5%88%86%E7%8E%AF%E5%A2%83/"/>
    <id>http://www.zbwblog.com/2019/08/08/客户端侧代码中区分环境/</id>
    <published>2019-08-08T14:46:00.000Z</published>
    <updated>2019-10-01T04:49:59.336Z</updated>
    
    <content type="html"><![CDATA[<p>在前端代码中，区分本地、开发、测试环境。<br><a id="more"></a><br><!-- toc --></p><ol><li><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>在前端代码中，区分本地、线上环境。</p></li><li><h2 id="为什么需要？"><a href="#为什么需要？" class="headerlink" title="为什么需要？"></a>为什么需要？</h2><p>开发插件服务时，我们常需要做一个demo页面，模拟真实使用场景来校验插件是否正常可用。</p><p>demo页面会在提测阶段在测试环境中供测试人员使用。</p><p>有时，我们需要区分是本地开发环境还是线上/测试环境，对业务代码做出一些调整。比如：访问地址，发到线上/测试环境时插件的访问地址可能不是服务器根目录，但本地开发环境中，我们相当于在根目录调试源码的。此时需要一个标识，进行区分。</p></li><li><h2 id="应用场景有哪些？"><a href="#应用场景有哪些？" class="headerlink" title="应用场景有哪些？"></a>应用场景有哪些？</h2><p>开发插件服务时的demo页面需要</p><p>应用程序中的跨域数据上报地址常常需要根据标识做区分</p></li><li><h2 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>使用webpack的别名功能。因为在webpack运行时，可以区分环境，根据标识，利用别名，引入不同的文件，然后在客户端侧代码中，使用这个别名即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config.resolve.alias</span><br><span class="line">     .set(<span class="string">'@'</span>, resolve(<span class="string">'src'</span>))</span><br><span class="line">     .set(</span><br><span class="line">       <span class="string">'webEnv'</span>,</span><br><span class="line">       process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">         ? resolve(<span class="string">'config/env.dev.js'</span>)</span><br><span class="line">         : resolve(<span class="string">'config/env.pro.js'</span>)</span><br><span class="line">     )</span><br></pre></td></tr></table></figure><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>使用webpack中的 <code>DefinePlugin</code> 插件。</p><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>如果你正在使用 <code>vue-cli3</code> ,服务中已经集成好了特定的api。</p><p><a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BE%A7%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">详见</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前端代码中，区分本地、开发、测试环境。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="插件" scheme="http://www.zbwblog.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="webpack" scheme="http://www.zbwblog.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>代码检查和格式化</title>
    <link href="http://www.zbwblog.com/2019/07/07/%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>http://www.zbwblog.com/2019/07/07/代码检查和格式化/</id>
    <published>2019-07-07T14:01:33.000Z</published>
    <updated>2019-10-01T04:56:46.640Z</updated>
    
    <content type="html"><![CDATA[<p>了解各种代码检查工具。<br><a id="more"></a><br><!-- toc --></p><h2 id="1-格式化相关的工具有哪些"><a href="#1-格式化相关的工具有哪些" class="headerlink" title="1. 格式化相关的工具有哪些"></a>1. 格式化相关的工具有哪些</h2><ul><li>EditorConfig</li><li>Prettier</li><li>Eslint</li><li>Tslint</li><li>Vetur（vsCode插件）</li><li>编辑器默认</li></ul><h2 id="2-工具介绍"><a href="#2-工具介绍" class="headerlink" title="2. 工具介绍"></a>2. 工具介绍</h2><h3 id="2-1-EditorConfig"><a href="#2-1-EditorConfig" class="headerlink" title="2.1. EditorConfig"></a>2.1. EditorConfig</h3><p><a href="https://editorconfig.org/" target="_blank" rel="noopener">官网</a></p><p>EditorConfig有助于为跨越各种编辑器和IDE的同一项目的多个开发人员维护一致的编码样式。 EditorConfig项目由用于定义编码样式的文件格式和一组文本编辑器插件组成，这些插件使编辑器能够读取文件格式并遵循定义的样式。 EditorConfig文件易于阅读，与版本控制系统配合使用。</p><p>配置文件命名：<code>.editorconfig</code></p><p>使用前置条件：</p><ol><li>安装 <code>editorconfig</code> 第三方包于 <code>node_modules</code></li><li>在根目录下配置 <code>.editorconfig</code> 文件</li><li>编辑器开启支持 <code>editorconfig</code> 配置（如vscode就是安装EditorConfig for VS Code扩展插件）</li></ol><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// editorconfig有些格式化生效条件是在保存时</span></span><br><span class="line"><span class="comment">// 未格式化状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123; \s\s</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存后，格式化完毕后状态：清空多余空白，末尾增加换行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后编辑器默认格式化程序，会按照editorconfig配置格式化，在保存时也会走相关配置。</p><h3 id="2-2-Prettier"><a href="#2-2-Prettier" class="headerlink" title="2.2. Prettier"></a>2.2. Prettier</h3><p><a href="https://github.com/prettier/prettier" target="_blank" rel="noopener">官网</a></p><p>Prettier是一个固执己见的代码格式化程序。它通过解析您的代码并使用自己的规则重新打印它来实施一致的样式，这些规则考虑到了最大的行长度，必要时包装代码。</p><p>它删除所有原始样式，并确保所有输出的代码符合一致的样式。</p><p>Prettier 在整个代码库中强制执行一致的代码样式（即不会影响AST的代码格式），因为它通过解析它来忽略原始样式*并使用自己的规则重新打印解析的AST，该规则采用最大行长度考虑到，必要时包装代码。</p><p>配置文件命名：<code>.prettierrc</code></p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于长度满足，它适合一行，所以它将保持原样。</span></span><br><span class="line">foo(arg1, arg2, arg3, arg4);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度不满足，它不适合一行，所以格式化</span></span><br><span class="line">foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prettier格式化结果</span></span><br><span class="line">foo(</span><br><span class="line">  reallyLongArg(),</span><br><span class="line">  omgSoManyParameters(),</span><br><span class="line">  IShouldRefactorThis(),</span><br><span class="line">  isThereSeriouslyAnotherOne()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象文字中打印括号之间的空格。</span></span><br><span class="line">&#123;<span class="attr">foo</span>: bar&#125;  =&gt; &#123; <span class="attr">foo</span>: bar &#125;</span><br></pre></td></tr></table></figure><p><strong>美化</strong>语法书写格式</p><p>只关注<strong>格式化</strong>，并<strong>不具有eslint检查语法等能力</strong>，只关心格式化文件(最大长度、混合标签和空格、引用样式等)，包括JavaScript · Flow · TypeScript · CSS · SCSS · Less · JSX · Vue · GraphQL · JSON · Markdown</p><h3 id="2-3-Eslint"><a href="#2-3-Eslint" class="headerlink" title="2.3. Eslint"></a>2.3. Eslint</h3><p>ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint --save-dev</span><br><span class="line"></span><br><span class="line">./node_modules/.bin/eslint --init</span><br><span class="line"></span><br><span class="line">./node_modules/.bin/eslint yourfile.js</span><br></pre></td></tr></table></figure><p>配置文件命名：<code>.eslintrc.js</code></p><p><strong>检查</strong>语法书写是否<strong>错误</strong></p><p>eslint 检查出的多为代码<strong>错误或优化</strong>，因此需要<strong>手动修正</strong></p><p>开启编辑器相关插件后（ESLint），则会提示相关语法错误，如变量定义未使用，const变量被修改</p><p>![示例/assets/images/images/eslint-example.png)</p><h3 id="2-4-Tslint"><a href="#2-4-Tslint" class="headerlink" title="2.4. Tslint"></a>2.4. Tslint</h3><p>TSLint是一种可扩展的静态分析工具，可检查TypeScript代码的可读性，可维护性和功能性错误。 它在现代编辑器和构建系统中得到广泛支持，可以使用您自己的lint规则，配置和格式化程序进行自定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yarn global add tslint typescript</span><br><span class="line"></span><br><span class="line">cd path/to/project</span><br><span class="line"></span><br><span class="line">tslint --init</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以tslint.json配置为规范，检查src/**/*.ts文件</span></span><br><span class="line">tslint -c tslint.json <span class="string">'src/**/*.ts'</span></span><br></pre></td></tr></table></figure><p>同理eslint</p><h3 id="2-5-Vetur"><a href="#2-5-Vetur" class="headerlink" title="2.5. Vetur"></a>2.5. Vetur</h3><p><a href="https://vuejs.github.io/vetur/formatting.html#formatters" target="_blank" rel="noopener">官网</a></p><p>可以格式化html、标准css（有分号 、大括号的那种）、标准js（有分号 、双引号的那种）、vue文件。</p><p>但是！格式化的标准js文件不符合ESlint规范，会给你加上双引号、分号等，像这样。<br>Vetur只有一个“整个文档格式化程序”，不能格式化任意范围。因此，只有Format Document命令可用。该Format Selection命令不起作用。</p><p>这些格式化程序可用：<br>prettier：对于css / scss / less / js / ts。<br>prettier-eslint：对于js。跑prettier和eslint –fix。<br>prettyhtml：对于HTML。<br>stylus-supremacy：对于手写笔。<br>vscode-typescript：对于js / ts。VS Code的js / ts格式化程序相同。</p><p>Vetur捆绑了格式化程序。当Vetur观察到格式化程序的本地安装时，它更喜欢使用本地版本。</p><p>您可以在VS Code config中选择每种语言的默认格式化程序vetur.format.defaultFormatter。 设置语言的格式化程序以none禁用该语言的格式化程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解各种代码检查工具。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="静态代码检查" scheme="http://www.zbwblog.com/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5/"/>
    
      <category term="eslint" scheme="http://www.zbwblog.com/tags/eslint/"/>
    
      <category term="tslint" scheme="http://www.zbwblog.com/tags/tslint/"/>
    
      <category term="prettier" scheme="http://www.zbwblog.com/tags/prettier/"/>
    
      <category term="editorConfig" scheme="http://www.zbwblog.com/tags/editorConfig/"/>
    
  </entry>
  
  <entry>
    <title>单元测试：jest（三）</title>
    <link href="http://www.zbwblog.com/2019/06/21/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.zbwblog.com/2019/06/21/单元测试（三）/</id>
    <published>2019-06-21T14:50:11.000Z</published>
    <updated>2019-10-01T04:02:49.321Z</updated>
    
    <content type="html"><![CDATA[<p>使用jest测试vue组件<br><a id="more"></a><br><br></p><p><img src="http://blog-assert.oss-cn-beijing.aliyuncs.com/%E5%86%85%E5%AE%B9/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/vue%E6%B5%8B%E8%AF%95.png" alt="aaa"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用jest测试vue组件&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="node" scheme="http://www.zbwblog.com/tags/node/"/>
    
      <category term="jest" scheme="http://www.zbwblog.com/tags/jest/"/>
    
      <category term="自动化测试" scheme="http://www.zbwblog.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="单元测试" scheme="http://www.zbwblog.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>单元测试：jest（二）</title>
    <link href="http://www.zbwblog.com/2019/06/21/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.zbwblog.com/2019/06/21/单元测试（二）/</id>
    <published>2019-06-21T14:45:10.000Z</published>
    <updated>2019-10-01T04:02:49.324Z</updated>
    
    <content type="html"><![CDATA[<p>jest—API分类。<br><a id="more"></a><br><br></p><p><img src="http://blog-assert.oss-cn-beijing.aliyuncs.com/%E5%86%85%E5%AE%B9/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/jest.png" alt="aaa"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jest—API分类。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="node" scheme="http://www.zbwblog.com/tags/node/"/>
    
      <category term="jest" scheme="http://www.zbwblog.com/tags/jest/"/>
    
      <category term="自动化测试" scheme="http://www.zbwblog.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="单元测试" scheme="http://www.zbwblog.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>单元测试：jest（一）</title>
    <link href="http://www.zbwblog.com/2019/06/21/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.zbwblog.com/2019/06/21/单元测试（一）/</id>
    <published>2019-06-21T14:21:31.000Z</published>
    <updated>2019-10-01T04:02:49.312Z</updated>
    
    <content type="html"><![CDATA[<p>用脑图的方式更全面认识单元测试。<br><a id="more"></a><br><br></p><p><img src="http://blog-assert.oss-cn-beijing.aliyuncs.com/%E5%86%85%E5%AE%B9/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.png" alt="aaa"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用脑图的方式更全面认识单元测试。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="node" scheme="http://www.zbwblog.com/tags/node/"/>
    
      <category term="jest" scheme="http://www.zbwblog.com/tags/jest/"/>
    
      <category term="自动化测试" scheme="http://www.zbwblog.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="单元测试" scheme="http://www.zbwblog.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>

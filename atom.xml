<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hero never die</title>
  
  <subtitle>码农界的一股清流</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zbwblog.com/"/>
  <updated>2020-02-01T10:37:42.649Z</updated>
  <id>http://www.zbwblog.com/</id>
  
  <author>
    <name>无畏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>new、call、apply、bind原理</title>
    <link href="http://www.zbwblog.com/2019/11/10/new%E3%80%81call%E3%80%81apply%E3%80%81bind%E5%8E%9F%E7%90%86/"/>
    <id>http://www.zbwblog.com/2019/11/10/new、call、apply、bind原理/</id>
    <published>2019-11-10T10:36:00.000Z</published>
    <updated>2020-02-01T10:37:42.649Z</updated>
    
    <content type="html"><![CDATA[<p>学习一道面试题。<br><a id="more"></a><br><!-- toc --></p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><ol><li>new的过程是在干什么</li><li>如何让生成的对象拥有实例属性和原型属性</li><li>如果构造函数执行后返回对象，那么new的结果是什么</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instanceA = <span class="keyword">new</span> Person(<span class="string">"zbw"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instanceA.age);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. new的结果无非是创建一个新对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 让 传入的构造函数 以这个对象 为this，执行，为这个对象设置实例属性和原型属性</span></span><br><span class="line">  <span class="comment">// 方法一</span></span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(obj, <span class="keyword">constructor</span>.prototype);</span><br><span class="line">  // 方法二</span><br><span class="line">  // obj.__proto__ = <span class="keyword">constructor</span>.prototype</span><br><span class="line"></span><br><span class="line">  const args = Array.from(arguments).slice(1);</span><br><span class="line">  const result = <span class="keyword">constructor</span>.call(obj, ...args);</span><br><span class="line"></span><br><span class="line">  return result instanceof Object ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line">const instanceB = mockNew(Person, "zbw");</span><br><span class="line">console.log(instanceB);</span><br><span class="line">console.log(instanceB.age);</span><br></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><ol><li>call方法作用</li><li>如何实现修改函数的this指向</li><li>如何实现序列化传参</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能用箭头函数，箭头函数没有this，找不到实例方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 将传入的context转成一个对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"手写call方法"</span>);</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 如何改变方法的this指向</span></span><br><span class="line">  <span class="comment">// 利用 xxx.fn  时  fn的this指向xxx</span></span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 处理参数传给实例函数执行</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  context.fn(...args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">say.call(</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"zbw"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>核心要点同call</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"手写apply方法"</span>);</span><br><span class="line">    context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    context.fn(...args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">say.apply(</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"zbw"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><ol><li>bind方法有哪些作用</li><li>如何改变函数this指向</li><li>如何实现参数部分持久化</li><li>？如果bind返回的方法，被new形式调用。那么函数中的this指的是谁</li><li>？new出来的结果可以找到原函数原型和实例上的属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">age, animal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我的名字是<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>，今年<span class="subst">$&#123;age&#125;</span>岁了，喜欢<span class="subst">$&#123;animal&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.animal = animal;</span><br><span class="line">&#125;</span><br><span class="line">say.prototype.sex = <span class="string">"男"</span>;</span><br><span class="line"><span class="comment">// const sayAdaptor = say.bind(&#123; name: "zbw" &#125;);</span></span><br><span class="line"><span class="comment">// sayAdaptor();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器环境正常， node环境中，报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变this指向，可以使用call、apply，但是低层都是使用一个三方对象作为中间层实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"手写bind方法"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> context = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">const</span> bindArgs = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bindFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    that.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> bindFn ? <span class="keyword">this</span> : context, bindArgs.concat(args));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Object.create()原理，利用中间层函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Fn.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  bindFn.prototype = <span class="keyword">new</span> Fn();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bindFn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于处理argument类数组对象时， Array.prototype.slice.call === [].slice.call</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindFn = say.bind(&#123; <span class="attr">name</span>: <span class="string">"zbw"</span> &#125;, <span class="string">"17"</span>);</span><br><span class="line">bindFn(<span class="string">"猫"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习一道面试题。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="面试" scheme="http://www.zbwblog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="js基础" scheme="http://www.zbwblog.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="http://www.zbwblog.com/2019/11/05/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://www.zbwblog.com/2019/11/05/深拷贝与浅拷贝/</id>
    <published>2019-11-05T09:49:00.000Z</published>
    <updated>2020-02-01T10:04:05.228Z</updated>
    
    <content type="html"><![CDATA[<p>学习一道面试题。<br><a id="more"></a><br><!-- toc --></p><h2 id="浅拷贝有哪些"><a href="#浅拷贝有哪些" class="headerlink" title="浅拷贝有哪些"></a>浅拷贝有哪些</h2><ul><li>…对象的展开运算符</li><li>数组的slice方法</li><li>Object.create()</li></ul><h2 id="深拷贝有哪些"><a href="#深拷贝有哪些" class="headerlink" title="深拷贝有哪些"></a>深拷贝有哪些</h2><ul><li>JSON.parse(JSON.stringify(obj))</li></ul><h2 id="JSON-parse-JSON-stringify-obj-有哪些不足"><a href="#JSON-parse-JSON-stringify-obj-有哪些不足" class="headerlink" title="JSON.parse(JSON.stringify(obj)) 有哪些不足"></a>JSON.parse(JSON.stringify(obj)) 有哪些不足</h2><ul><li>无法拷贝函数</li><li>无法拷贝对正则、日期对象</li><li>无法拷贝undefined</li><li>对于存在循环引用的对象，报错</li></ul><h2 id="如何实现一个深拷贝"><a href="#如何实现一个深拷贝" class="headerlink" title="如何实现一个深拷贝"></a>如何实现一个深拷贝</h2><ol><li>传入参数不合法时，如null</li><li>如果是正则、日期对象如何处理</li><li>如果是普通数值类型如何处理</li><li>当传入参数是数组、对象、函数时，如何优雅地处理，</li><li>存在循环引用时，如何处理</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  name: <span class="string">"zbw"</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    province: <span class="string">"河北"</span>,</span><br><span class="line">    city: <span class="string">"定州"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  birthday: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  sex: <span class="literal">undefined</span>,</span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">info.o = info;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const a = JSON.parse(JSON.stringify(info));</span></span><br><span class="line"><span class="comment">// console.log(a);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">obj, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3 由于操作函数的行为一般只是执行，不涉及到修改。故返回即可，再此只对对象和数组做处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span>) <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5</span></span><br><span class="line">  <span class="keyword">if</span> (hash.get(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> obj.constructor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5 克隆后，使用弱引用WeakMap以对象作为key，将值存起来</span></span><br><span class="line">  <span class="comment">// 下面执行过过程中遇到存在属性值是父对象，产生循环引用的问题时</span></span><br><span class="line">  <span class="comment">// 如果在map映射中找到了，则直接返回即可</span></span><br><span class="line">  hash.set(obj, result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      result[key] = cloneDeep(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = cloneDeep(info);</span><br><span class="line">result.address.province = <span class="string">"北京"</span>;</span><br><span class="line">result.birthday = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">12312331312312</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习一道面试题。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="面试" scheme="http://www.zbwblog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="js基础" scheme="http://www.zbwblog.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>0.1+0.2为什么不等于0.3</title>
    <link href="http://www.zbwblog.com/2019/11/03/0.1+0.2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8E0.3/"/>
    <id>http://www.zbwblog.com/2019/11/03/0.1+0.2为什么不等于0.3/</id>
    <published>2019-11-03T09:42:00.000Z</published>
    <updated>2020-02-01T10:03:27.209Z</updated>
    
    <content type="html"><![CDATA[<p>学习一道面试题。<br><a id="more"></a><br><!-- toc --></p><p>计算机运算时只能识别二进制数值，即所有运算中的数字都是有无数个0和1组成的。</p><p>0.1+0.2运算之前也是先分别将十进制小数转成二进制后，进行加法运算，将得到的二进制数与十进制小数0.3转成二进制数进行比较。</p><p>由于十进制小数0.1和0.2转成二进制后无穷尽，根据双精度浮点数规则，计算机会将其截断，四舍五入，所以相加得到的二进制数会0.3直接转成二进制数大一些。</p><p>所以会出现0.1+0.2为什么不等于0.3。</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>十进制小数如何转化为二进制数值</p><p>二级制数值相加规则，满2进1</p><h2 id="2进制与10进制之间转换"><a href="#2进制与10进制之间转换" class="headerlink" title="2进制与10进制之间转换"></a>2进制与10进制之间转换</h2><p>2——&gt;10: parseInt(11, 2)  // 3</p><p>10——&gt;2: 10.toString(2)   // ‘1010’</p><p>整数之间的进制转换还是比较简单的，那么小数呢?</p><h2 id="0-5转成二进制"><a href="#0-5转成二进制" class="headerlink" title="0.5转成二进制"></a>0.5转成二进制</h2><p>0.5 = n<em>2^-1 + m</em>2^-2 + …</p><p>左右两边同时乘2</p><p>1 = n<em>2^0 + m</em>2^-1 + …</p><p>由于从2^0开始，才会有整数部分，此时我们就可以看出</p><p>1 = n*2^0</p><p>n = 1</p><p>所以，得到结果：十进制的0.5转换成二进制后为2^-1，那么0.1转换成二进制是什么呢</p><h2 id="0-1转换成二进制是什么"><a href="#0-1转换成二进制是什么" class="headerlink" title="0.1转换成二进制是什么"></a>0.1转换成二进制是什么</h2><p>0.1 = n<em>2^-1 + m</em>2^-2 + …</p><p>0.2 = n<em>2^0 + m</em>2^-1 + …   // 由于左边没有整数，所以 n=0, 此时最后结果的首位推导出为0</p><p>0.4 = … + a<em>2^0 + b</em>2^-1 + …  // 由于左边仍没有整数，所以此时最后结果推导出为00</p><p>0.8 = … + a<em>2^0 + b</em>2^-1 + …  // 由于左边仍没有整数，所以此时最后结果推导出为000</p><p>1.6 = … + a<em>2^0 + b</em>2^-1 + …  // 由于左边有整数，所以此时 a = 1, 最后结果推导出为0001</p><p>0.6 <em> 2 = …+ b</em>2^0 + c*2^1 + …  // 由于左边有整数，所以此时 b = 1, 最后结果推导出为00011</p><p>如此推导，得到0.1的二进制表示为：00011001100110011…</p><p>由上可以知道，0.1的二进制结果，是无穷尽的小数，计算机内会对最后的结果，在一定的小数位时，四舍五入。</p><p>计算机计算0.1的二进制时就已经准确了，那么计算0.2，以及最后相加的结果与0.3相比较，就会出现0.1 + 0.2 != 0.3的情况</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>0.1+0.2不等于0.3是因为计算机将小数转化为2进制时，由于部分小数无穷尽，进行运算时计算机会四舍五入，无法得到期待结果所对应的2进制表示</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习一道面试题。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="面试" scheme="http://www.zbwblog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="js基础" scheme="http://www.zbwblog.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>手写一个简版promise</title>
    <link href="http://www.zbwblog.com/2019/10/05/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E7%89%88promise/"/>
    <id>http://www.zbwblog.com/2019/10/05/手写一个简版promise/</id>
    <published>2019-10-04T18:20:00.000Z</published>
    <updated>2019-11-04T09:40:17.464Z</updated>
    
    <content type="html"><![CDATA[<p>记住四句话，学会手写一个简版promise。<br><a id="more"></a><br><!-- toc --></p><h2 id="promise-是什么"><a href="#promise-是什么" class="headerlink" title="promise 是什么"></a>promise 是什么</h2><p>promise是一个构造函数/类</p><h2 id="promise-存在的价值"><a href="#promise-存在的价值" class="headerlink" title="promise 存在的价值"></a>promise 存在的价值</h2><p>解决并发问题，多个异步任务的执行结果</p><p>解决链式问题，第二个接口依赖于第一个接口，解决回调地狱问题</p><h2 id="promise-特点"><a href="#promise-特点" class="headerlink" title="promise 特点"></a>promise 特点</h2><ol><li><p>每次new一个promise实例时，都需要传递一个执行器函数executor，并且执行器函数会立即执行</p></li><li><p>执行器函数有两个参数 resolve reject</p></li><li><p>每个promise都有一个状态标识，有三种状态类型：</p><p>pending =&gt; resolve 成功了</p><p>pending =&gt; reject 失败了</p></li><li><p>状态可以改变，一旦改变不可以再次更改</p><p>一旦成功了，不能再变成失败，一旦失败了，不能再变成成功<br> （什么时候可以改变状态呢？ ）</p></li><li><p>如果执行器函数在执行时，抛出异常如 <code>throw new Error(&#39;自定义错误&#39;)</code> ，那promise应该变成失败状态，会被.then时的 <code>onRejected</code> 处理错误的函数接收</p></li></ol><h2 id="如何手写一个简版-promise"><a href="#如何手写一个简版-promise" class="headerlink" title="如何手写一个简版 promise"></a>如何手写一个简版 promise</h2><h3 id="既然-promise-是一个构造函数-类，那么它-new-时可以传递哪些参数，这些参数又是做什么用的"><a href="#既然-promise-是一个构造函数-类，那么它-new-时可以传递哪些参数，这些参数又是做什么用的" class="headerlink" title="既然 promise 是一个构造函数/类，那么它 new 时可以传递哪些参数，这些参数又是做什么用的"></a>既然 promise 是一个构造函数/类，那么它 new 时可以传递哪些参数，这些参数又是做什么用的</h3><p>executor、resolve、reject</p><p>executor执行业务逻辑（同步/异步），在适当的时机调用，resolve/reject。</p><p>如数据成功返回时，调用resolve函数，将promise实例变成成功态，并将数据告诉promise实例，promise实例拿到数据后，先暂存起来，当promise实例被手动调用.then方法时，供then方法第一个处理成功信息的函数nFullfilled使用</p><p>如数据返回失败/代码报错时，调用reject函数，将promise实例变成失败态，并将失败原因告诉promise实例，promise实例拿到失败原因后，先暂存起来，当promise实例被手动调用.then方法时，供then方法第二个处理失败信息的函数onRejected使用</p><h3 id="为了实现上述功能，每个-promise-实例应该具有哪些内部状态"><a href="#为了实现上述功能，每个-promise-实例应该具有哪些内部状态" class="headerlink" title="为了实现上述功能，每个 promise 实例应该具有哪些内部状态"></a>为了实现上述功能，每个 promise 实例应该具有哪些内部状态</h3><ol><li>用户手动调用的resolve、reject函数不需要自己声明变量，所以调用的应该是new Promise() 时， Promise函数内部作用域的变量 =&gt; constructor 中的resolve和 reject</li><li>resolve函数可以改变promise状态，每个promise都有一个状态标识，标识当前状态 =&gt; this.status</li><li>当resolve(data) / reject(reason)时，promise需要暂存外部告知的<strong>数据</strong>或<strong>失败原因</strong>，并且当外部手动调用then时，还需要用到 =&gt; this.value  this.reason</li><li>promise实例可以被手动调用then方法，处理成功时的数据或失败时的原因 =&gt; this.then()</li></ol><h3 id="当-executor-函数只有同步时：2-gt-1-resolve-‘回答正确’-throw-new-Error-‘原则性错误’"><a href="#当-executor-函数只有同步时：2-gt-1-resolve-‘回答正确’-throw-new-Error-‘原则性错误’" class="headerlink" title="当 executor 函数只有同步时：2 &gt; 1 ? resolve(‘回答正确’) : throw new Error(‘原则性错误’)"></a>当 executor 函数只有同步时：2 &gt; 1 ? resolve(‘回答正确’) : throw new Error(‘原则性错误’)</h3><p>由于executor函数会立即执行，所以如果该函数都是同步逻辑，promise状态会立即改变，数据会立即暂存，所以后面.then时，可以立即处理对应的数据。</p><h3 id="当-executor-函数存在异步时：setTimeOut-gt-resolve-‘async’-2000"><a href="#当-executor-函数存在异步时：setTimeOut-gt-resolve-‘async’-2000" class="headerlink" title="当 executor 函数存在异步时：setTimeOut(() =&gt; resolve(‘async’), 2000)"></a>当 executor 函数存在异步时：setTimeOut(() =&gt; resolve(‘async’), 2000)</h3><p>但是当executor函数中有异步逻辑时，resolve函数不会马上执行，但是.then会在 new Promise 后马上执行。但此时promise还处于pending状态，所以我们需要在原型的then方法中，当状态是pending时，先将用户传来的处理数据/异常的方法暂存进一个队列，当调用resolve/reject，在从队列中遍历执行处理方法。此处使用发布订阅模式。</p><p>故promise增加onResolvedCallBacks、onRejectedCallBacks两个数组实例属性，暂存处理函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'——————————————————————————手写的promise——————————————————————'</span>)</span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> FULLFILLED = <span class="string">'fullFilled'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING</span><br><span class="line">    <span class="comment">// 两个队列 专门存成功的和失败的 为了处理异步 发布订阅模式</span></span><br><span class="line">    <span class="keyword">this</span>.onResolvedCallBacks = []</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallBacks = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有pending状态时才可以改变promise的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = FULLFILLED</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallBacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = REJECTED</span><br><span class="line">        <span class="keyword">this</span>.reason = reason</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallBacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传递一个执行器 执行器会立即执行</span></span><br><span class="line">    <span class="comment">// 这里可能会发生异常</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      executor(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then方法会判断当前的状态</span></span><br><span class="line">  then(onFullfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULLFILLED) &#123;</span><br><span class="line">      onFullfilled(<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">      onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步 pending 时调用then   resolve 需要在 then 之后执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="comment">// ** todo</span></span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallBacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        onFullfilled(<span class="keyword">this</span>.value)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallBacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记住四句话，学会手写一个简版promise。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="面试" scheme="http://www.zbwblog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="js" scheme="http://www.zbwblog.com/tags/js/"/>
    
      <category term="promise" scheme="http://www.zbwblog.com/tags/promise/"/>
    
      <category term="es6" scheme="http://www.zbwblog.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>管理一个npm包</title>
    <link href="http://www.zbwblog.com/2019/10/04/%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AAnpm%E5%8C%85/"/>
    <id>http://www.zbwblog.com/2019/10/04/管理一个npm包/</id>
    <published>2019-10-04T12:26:00.000Z</published>
    <updated>2019-10-05T08:33:04.552Z</updated>
    
    <content type="html"><![CDATA[<p>学习管理一个属于自己的npm包。<br><a id="more"></a><br><!-- toc --></p><h2 id="发布一个npm包"><a href="#发布一个npm包" class="headerlink" title="发布一个npm包"></a>发布一个npm包</h2><ol><li><p>注册npm官方账号</p><p>执行 <code>npm addUser</code> 或者 去npm官网手动注册。</p><p>注意：注册成功后，需要邮箱验证，否则在发布时，会报403错误。</p></li><li><p>创建一个包项目</p><p>执行 <code>npm init -y</code></p></li><li><p>修改package.json文件</p><p>字段名称 | 含义<br>-|-|-<br>name | 报名<br>private | 是否发布到私有仓库<br>version | 包版本包<br>main | 指定使用者import包时的入口文件，优先级低<br>module | 指定使用者import包时的入口文件，优先级高</p><p>注意：发布到npm上时，name、version、main字段是必须要设置的。</p></li><li><p>登录npm</p><p>执行 <code>npm login</code>，输入之前注册的账号、密码邮箱。</p></li><li><p>使用nrm将npm的源切换到官方源</p></li><li><p>发布</p><p>执行 <code>npm publish</code> 开始发布</p></li><li>123</li><li>123</li></ol><h2 id="更新已有npm包"><a href="#更新已有npm包" class="headerlink" title="更新已有npm包"></a>更新已有npm包</h2><p>更新已有包后，在npm上的 <code>version</code> 中可以查看本包的所有版本</p><ol><li>更新 <strong>package.json</strong> 文件中的版本号</li><li>执行 <code>npm publish</code> 开始发布</li></ol><h2 id="删除npm包"><a href="#删除npm包" class="headerlink" title="删除npm包"></a>删除npm包</h2><p>删除指定版本：执行 <code>npm unpublish 包名@版本号</code></p><p>删除整个包：执行 <code>npm unpublish 包名 --force</code></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>增加 .gitignore 文件忽略提交无效文件</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习管理一个属于自己的npm包。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="npm" scheme="http://www.zbwblog.com/tags/npm/"/>
    
      <category term="node" scheme="http://www.zbwblog.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>菜单权限控制</title>
    <link href="http://www.zbwblog.com/2019/10/03/%E8%8F%9C%E5%8D%95%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.zbwblog.com/2019/10/03/菜单权限控制/</id>
    <published>2019-10-02T18:02:00.000Z</published>
    <updated>2019-11-04T09:40:17.491Z</updated>
    
    <content type="html"><![CDATA[<p>如何让不同身份的用户，得到不同的菜单？<br><a id="more"></a><br><!-- toc --></p><p>菜单权限控制是值用户在访问系统时，根据用户的身份限制用户能够访问的菜单项</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><ol><li>前端配置<strong>默认路由列表</strong>、<strong>全部权限路由列表</strong></li><li>默认路由对象一般只配置 * 和 /</li><li>服务器端定义接口，根据用户信息返回该用户的<strong>实际权限路由列表标识</strong></li><li>前端在 <code>main.js</code> 中设置路由的 <code>beforeEach</code> 钩子，在用户访问每个页面时，请求权限校验接口，拿到<strong>实际权限路由列表标识</strong></li><li>处理<strong>实际权限路由列表标识</strong>和<strong>全部权限路由列表</strong>得到<strong>实际权限路由列表</strong></li><li><p>将<strong>实际权限路由列表</strong>动态添加到<strong>默认路由列表</strong>中得到<strong>该用户真实路由列表</strong></p><p><code>router.addRoutes()</code></p><p><code>next({...to, replace:true})</code></p><p>由于addRoute  有可能不会马上成功  所以官方推荐加上replace（消除历史记录）</p></li><li><p>实际权限路由标识列表缓存在 <code>vuex</code> 中一份，减少接口调用次数</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何让不同身份的用户，得到不同的菜单？&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="面试" scheme="http://www.zbwblog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="业务功能" scheme="http://www.zbwblog.com/tags/%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD/"/>
    
      <category term="权限控制" scheme="http://www.zbwblog.com/tags/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    
      <category term="vue" scheme="http://www.zbwblog.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>jwt实现</title>
    <link href="http://www.zbwblog.com/2019/10/03/jwt%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.zbwblog.com/2019/10/03/jwt实现/</id>
    <published>2019-10-02T17:17:00.000Z</published>
    <updated>2019-11-04T09:40:17.488Z</updated>
    
    <content type="html"><![CDATA[<p>一张流程图指导jwt登录权限校验功能的实现。<br><a id="more"></a><br><!-- toc --></p><h2 id="什么是jwt"><a href="#什么是jwt" class="headerlink" title="什么是jwt"></a>什么是jwt</h2><p>jwt 全称 json web token，可以看成是基于token的登录权限控制</p><h2 id="jwt流程图"><a href="#jwt流程图" class="headerlink" title="jwt流程图"></a>jwt流程图</h2><p><img src="/assets/images/jwt流程图.png" alt="jwt流程图优化后"></p><h2 id="axios-封装"><a href="#axios-封装" class="headerlink" title="axios 封装"></a>axios 封装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AjaxRequest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.baseURL = process.env.NODE_ENV === <span class="string">'development'</span> ? <span class="string">'http://localhost:3000'</span> : <span class="string">'/'</span></span><br><span class="line">    <span class="keyword">this</span>.timeout = <span class="number">2000</span></span><br><span class="line">  &#125;</span><br><span class="line">  request(config) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">      baseURL: <span class="keyword">this</span>.baseURL,</span><br><span class="line">      timeout: <span class="keyword">this</span>.timeout</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置拦截器</span></span><br><span class="line">    instance.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">      config.header.Authorization = localStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">      <span class="keyword">return</span> config</span><br><span class="line">    &#125;, err =&gt; <span class="built_in">Promise</span>.reject(err))</span><br><span class="line"></span><br><span class="line">    instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> res.data, err =&gt; <span class="built_in">Promise</span>.reject(err))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance(config)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> AjaxRequest()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一张流程图指导jwt登录权限校验功能的实现。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="面试" scheme="http://www.zbwblog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="业务功能" scheme="http://www.zbwblog.com/tags/%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD/"/>
    
      <category term="权限控制" scheme="http://www.zbwblog.com/tags/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    
      <category term="vue" scheme="http://www.zbwblog.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化</title>
    <link href="http://www.zbwblog.com/2019/10/02/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://www.zbwblog.com/2019/10/02/前端模块化/</id>
    <published>2019-10-02T14:37:00.000Z</published>
    <updated>2019-11-04T09:40:17.486Z</updated>
    
    <content type="html"><![CDATA[<p>整理学习前端模块概念及模块化规范。<br><a id="more"></a><br><!-- toc --></p><h2 id="模块的基本要求"><a href="#模块的基本要求" class="headerlink" title="模块的基本要求"></a>模块的基本要求</h2><ol><li>隐藏模块内部实现，使模块的使用者无需关注模块内部实现的细节</li><li>对外定义模块的访问接口，通过接口可以调用模块功能</li></ol><h2 id="模块接口"><a href="#模块接口" class="headerlink" title="模块接口"></a>模块接口</h2><p>模块接口通常包含一组变量和函数，创建接口最简单的方式是使用js对象</p><h2 id="四种模块方式实现"><a href="#四种模块方式实现" class="headerlink" title="四种模块方式实现"></a>四种模块方式实现</h2><p>目标：实现一个util模块，外部可以调用模块的add工具方法</p><h3 id="函数模块"><a href="#函数模块" class="headerlink" title="函数模块"></a>函数模块</h3><p>使用自执行的匿名函数（IIFE）实现隐藏内部实现要求</p><p>使用闭包、对象实现对外定义模块的访问接口要求</p><p>扩展时，需要调用一个IIFE，改函数接收需要扩展的模块变量作为参数</p><p><img src="/assets/images/函数模块.png" alt="函数模块"></p><p>函数模块缺点</p><ol><li>通过模块扩展无法共享模块的私有变量</li><li>当我们开始创建模块化应用时，模块本身尝尝依赖其他模块的功能，然而函数模块模块无法实现这些依赖关系</li></ol><h3 id="AMD-和-CommonJs"><a href="#AMD-和-CommonJs" class="headerlink" title="AMD 和 CommonJs"></a>AMD 和 CommonJs</h3><p>为了弥补函数模块的缺点，AMD 与 CommonJs两大<strong>标准</strong>产生，并相互竞争。</p><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><ol><li>ADM最流行的实现是<strong>RequireJs</strong></li><li>设计理念是明确基于浏览器</li><li>自动处理依赖，无需考虑模块引入问题</li><li>异步加载依赖模块，避免阻塞 （解决前端应用场景中向服务器请求依赖模块文件问题）</li><li>所有依赖模块加载完毕后，调用模块的工厂函数，并传入依赖模块</li><li>在同一个文件中可以定义多个模块</li><li>对外提供模块访问接口的实现方式与函数模块一致</li></ol><p><img src="/assets/images/AMD模块.png" alt="AMD模块"></p><h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h4><ol><li>每个文件，只能定义一个模块</li><li>module.exports 作为模块的公共接口</li><li>可以引入依赖模块，依赖同步加载 （由于服务器端常读磁盘文件，速度较快，与http请求速度不在同一个量级，所以使用同步加载）</li><li>变量可以定义在文件的顶部，虽然是顶部，但仍属于模块内部的局部变量</li><li>nodeJs 默认的模块标准</li></ol><p>CommonJs缺点</p><p>不显式的支持浏览器</p><p><img src="/assets/images/CommonJs.png" alt="CommonJs"></p><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>在模块规范百家争鸣下，为实现统一的模块化标准，UMD产生了。</p><p>实现原理</p><p>先判断运行环境是否支持cjs，然后判断是否支持amd，如果都不支持，则使用函数模块方式（IIFE），生成一个全局变量。</p><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>主要思想：必须显式的使用标识符导出模块，才能从外部访问模块</p><p>虽然变量可以定义在模块顶部，但是仍然只能在模块内部访问变量</p><p>目前浏览器尚未支持ES6模块，如果现在需要ES6模块，需要对代码进行编译，可以使用Traceur 或 babel 或 typescript</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td>export const add = (a, b) =&gt; a + b</td><td>导出变量</td></tr><tr><td>export function add (a, b) { return a + b}</td><td>导出函数</td></tr><tr><td>export class add {}</td><td>导出类</td></tr><tr><td>export default class add {}</td><td>导出默认类</td></tr><tr><td>export default function() {}</td><td>导出默认函数</td></tr><tr><td>export default add</td><td>导出默认对象</td></tr><tr><td>export { add, delete }</td><td>导出存在的变量  命名导出</td></tr><tr><td>export { add as add1 }</td><td>使用别名导出变量</td></tr><tr><td>export default function () {} export { add }</td><td>同时使用默认导出和命名导出</td></tr></tbody></table><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td>import add from ‘./add’</td><td>导入默认导出</td></tr><tr><td>import { add } from ‘./add’</td><td>导入命名导出</td></tr><tr><td>import * as all from ‘./add’</td><td>导入模块中声明的全部导出</td></tr><tr><td>import add, { add } from ‘./add’</td><td>同时导入默认导出和命名导出</td></tr><tr><td>import { add as add1 } from ‘./add’</td><td>通过别名导入模块中声明的全部导出，到本模块依赖两个不同模块内容，并且依赖内容命名一致时使用</td></tr></tbody></table><p><img src="/assets/images/es6模块.png" alt="es6模块"></p><h4 id="主文件进行模块管理"><a href="#主文件进行模块管理" class="headerlink" title="主文件进行模块管理"></a>主文件进行模块管理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/index.js   作为中间层导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'shared/util'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./lang'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./env'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./options'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./debug'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./props'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./error'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./next-tick'</span></span><br><span class="line"><span class="keyword">export</span> &#123; defineReactive &#125; <span class="keyword">from</span> <span class="string">'../observer/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js  作为使用方调用</span></span><br><span class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">'./util/index.js'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理学习前端模块概念及模块化规范。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="面试" scheme="http://www.zbwblog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="规范" scheme="http://www.zbwblog.com/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="js" scheme="http://www.zbwblog.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>使用postMessage+iframe开发插件式服务</title>
    <link href="http://www.zbwblog.com/2019/10/01/%E4%BD%BF%E7%94%A8postMessage+iframe%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6%E5%BC%8F%E6%9C%8D%E5%8A%A1/"/>
    <id>http://www.zbwblog.com/2019/10/01/使用postMessage+iframe开发插件式服务/</id>
    <published>2019-10-01T04:45:00.000Z</published>
    <updated>2019-10-01T04:56:46.626Z</updated>
    
    <content type="html"><![CDATA[<p>与iframe通信的那些事儿。<br><a id="more"></a><br><!-- toc --></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>调用方</strong>：调用iframe服务的一方</p><p><strong>服务方</strong>：在iframe中，开发页面服务的一方</p><h2 id="调用方"><a href="#调用方" class="headerlink" title="调用方"></a>调用方</h2><ol><li><p>调用方使用url传参方式对iframe项目进行初始化<br><img src="/assets/images/iframe-message0.png" alt="调用方使用url传参方式对iframe项目进行初始化"></p></li><li><p>监听服务方派发出的事件<br><img src="/assets/images/iframe-message1.png" alt="监听服务方派发出的事件"></p></li><li><p>调用方通过postMessage向服务方传递数据<br><img src="/assets/images/iframe-message2.png" alt="调用方使用url传参方式对iframe项目进行初始化"></p></li></ol><h2 id="服务方"><a href="#服务方" class="headerlink" title="服务方"></a>服务方</h2><ol><li><p>服务方通过url获取参数，对项目进行初始化<br><img src="/assets/images/iframe-message3.png" alt="调用方使用url传参方式对iframe项目进行初始化"></p></li><li><p>服务方派发消息给调用方<br><img src="/assets/images/iframe-message4.png" alt="调用方使用url传参方式对iframe项目进行初始化"></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与iframe通信的那些事儿。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="iframe" scheme="http://www.zbwblog.com/tags/iframe/"/>
    
      <category term="postMessage" scheme="http://www.zbwblog.com/tags/postMessage/"/>
    
      <category term="插件" scheme="http://www.zbwblog.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>性能优化—http</title>
    <link href="http://www.zbwblog.com/2019/10/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94http/"/>
    <id>http://www.zbwblog.com/2019/10/01/性能优化——http/</id>
    <published>2019-10-01T03:59:21.000Z</published>
    <updated>2019-11-04T09:40:17.483Z</updated>
    
    <content type="html"><![CDATA[<p>介绍压缩、缓存是如何实现的。<br><a id="more"></a><br><!-- toc --></p><h2 id="http主要优化方式"><a href="#http主要优化方式" class="headerlink" title="http主要优化方式"></a>http主要优化方式</h2><ol><li><strong>压缩</strong></li><li><strong>缓存</strong></li></ol><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><h3 id="http压缩与uglify压缩区别"><a href="#http压缩与uglify压缩区别" class="headerlink" title="http压缩与uglify压缩区别"></a>http压缩与uglify压缩区别</h3><ol><li><p>uglify压缩js代码中的空格、空行，混淆代码指将过长变量名统一替换成简单字符</p></li><li><p>http压缩是将文件内容中重复的部分进行压缩，如html中重复的标签名，重复的部分越多，压缩质量越高</p><p>视频，音频相关的文件，压缩质量很低</p><p>压缩完是可以解压的，而不是删除内容</p></li></ol><h3 id="压缩流程"><a href="#压缩流程" class="headerlink" title="压缩流程"></a>压缩流程</h3><ol><li><p>客户端发出http请求文件时，请求头中的 <code>Accept-Encoding</code> 字段告知服务器，自身支持哪种压缩格式</p><p>例：<code>Accept-Encoding: br;q=1.0, gzip;q=0.8, *;q=0.1</code></p><p>q是权重 1最高</p></li><li><p>服务器收到请求后，根据请求头中的 <code>Accept-Encoding</code>  字段知道了客户端浏览器支持的压缩格式，如果有压缩，没有就不压缩。压缩完成后，写入文件，返回给客户端浏览器</p><p>并在 <code>response Header</code> 中返回 <code>content-encoding</code> 字段告知浏览器，文件是以什么样的格式进行压缩的，否则浏览器无法正确解析压缩过后的文件，会出现乱码</p><p>例：<code>content-encoding: gzip</code></p><p>node压缩格式一般是 <code>gzip、 deflate</code></p></li></ol><h3 id="压缩原理"><a href="#压缩原理" class="headerlink" title="压缩原理"></a>压缩原理</h3><p>压缩功能实现是使用node专用于做压缩的zlib模块，zlib模块压缩方式：</p><ol><li><p>同步压缩：等文件所有内容压缩完，在返回给客户端</p></li><li><p>流式压缩：一边压缩一边返回</p><p>实际上是借助<strong>转换流</strong>的概念，将目标文件读取出来，经过转换流压缩，在返回给客户端。</p><p><code>可读流.pipe(zlib.createGzip()).pipe(可写流)</code></p></li></ol><h3 id="压缩实战"><a href="#压缩实战" class="headerlink" title="压缩实战"></a>压缩实战</h3><ol><li>webpack 的 devServer 中的 <code>compress</code> 属性</li></ol><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存指，客户端浏览器请求服务器获取到资源后，同时会将资源复制一份缓存至本地硬盘中的一个文件内。</p><p>再次请求服务器同一资源时，会被服务器返回的信息告知从自己的缓存文件夹中获取即可。</p><p>这个交互过程实现了资源的缓存</p><h3 id="缓存的方式"><a href="#缓存的方式" class="headerlink" title="缓存的方式"></a>缓存的方式</h3><ol><li><strong>强制缓存</strong></li><li><strong>对比缓存（协商缓存）</strong></li><li><strong>指纹缓存</strong></li></ol><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><h4 id="什么是强制缓存"><a href="#什么是强制缓存" class="headerlink" title="什么是强制缓存"></a>什么是强制缓存</h4><p>客户端发起请求，服务器在返回资源的同时，在<strong>响应中</strong>设置 <code>Cache-Control</code> 或者 <code>Expires</code> 告知客户端浏览器：<strong>10秒之内</strong>、或在<strong>规定日期之前</strong>不要再找我了，从你的缓存文件夹中取！</p><p>走强制缓存时，响应状态码为200</p><h4 id="Cache-Control-与-Expires-区别"><a href="#Cache-Control-与-Expires-区别" class="headerlink" title="Cache-Control 与 Expires 区别"></a>Cache-Control 与 Expires 区别</h4><ol><li><p>写法不同</p><p><code>Cache-Control: max-age=10</code></p><p><code>Expires: Expires: Wed, 21 Oct 2015 07:28:00 GMT</code></p></li><li><p>单位不同</p><p>Cache-Control 单位是秒，是<strong>相对时间</strong>，表示多少秒之后</p><p>Expires 单位是UTC，也就是我们所说的<strong>格林威治时间</strong>，指的是time中的<strong>世界时间标准</strong>。是绝对时间，表示过期时间是什么时候。</p></li><li><p>权重不同</p><p>因为Expires是老版本设置， 设置Cache-Control 会覆盖掉 Expires</p></li></ol><h4 id="强制缓存缺点"><a href="#强制缓存缺点" class="headerlink" title="强制缓存缺点"></a>强制缓存缺点</h4><p>服务器文件更新之后，在没有超过规定时间时，客户端浏览器仍会走缓存，访问旧文件</p><h3 id="对比缓存（协商缓存）304"><a href="#对比缓存（协商缓存）304" class="headerlink" title="对比缓存（协商缓存）304"></a>对比缓存（协商缓存）304</h3><h4 id="什么是对比缓存"><a href="#什么是对比缓存" class="headerlink" title="什么是对比缓存"></a>什么是对比缓存</h4><p>客户端请求第一次时，服务器在response中设置 <code>Last-Modified</code> ，告之客户端这个文件最新修改时间。</p><p>客户端下次再请求时，在request中会携带 <code>If-Modified-Since</code> 这个时间戳标识，服务器比较标识，如果标识不同，证明后来又被修改过，返回新文件。否则告知客户端：文件没有变化，从缓存中去取吧。</p><p>走对比缓存时，<strong>响应状态码为304</strong></p><h4 id="对比缓存缺点"><a href="#对比缓存缺点" class="headerlink" title="对比缓存缺点"></a>对比缓存缺点</h4><ol><li>反复操作文件，虽然文件内容没变，但是最后修改时间改了。客户端不会走缓存。</li><li>cdn分发时间不同，会导致得到不一样的结果</li></ol><h3 id="指纹缓存"><a href="#指纹缓存" class="headerlink" title="指纹缓存"></a>指纹缓存</h3><h4 id="什么是指纹缓存"><a href="#什么是指纹缓存" class="headerlink" title="什么是指纹缓存"></a>什么是指纹缓存</h4><p>首次接到请求后，摘要/加盐文件部分内容，生成唯一key，名为 <code>Etag</code> 传给客户端。</p><p>客户端下次再请求同一文件时，在request中加入请求头 <code>If-None-Match</code></p><p>服务器端收到后作比较，更加准确的判断文件是否被修改过，后续同对比缓存</p><p>例</p><p><code>ETag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</code></p><p><code>If-None-Match: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</code></p><h4 id="什么是MD5"><a href="#什么是MD5" class="headerlink" title="什么是MD5"></a>什么是MD5</h4><p>MD5是一种信息摘要算法，摘取文件部分内容。</p><p>MD5本来也不是作加密使用，而是用来<strong>校验数据的完整性</strong>。</p><p>MD5不算是加密算法，因为摘要不代表全部内容，不可解密，不可反推，就是无论多大数据，经过算法运算后都是<strong>生成固定长度</strong>的数据。</p><p>相同的内容摘要的结果相同。有一点不同，摘要的结果完全不同。</p><h4 id="使用MD5"><a href="#使用MD5" class="headerlink" title="使用MD5"></a>使用MD5</h4><p><code>Crypto.createHash(&#39;md5&#39;).update(&#39;文件部分内容&#39; + random() ).digest(&#39;base64&#39;)</code></p><p>由于MD5大家都知道，很容易被猜到，所以在摘要时加一个随机数。</p><h4 id="什么是加盐"><a href="#什么是加盐" class="headerlink" title="什么是加盐"></a>什么是加盐</h4><p>使用 <code>sha1</code> <code>sha256</code> 这种加密算法，流程同MD5相同</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>开启所有类型缓存，只要有一个失效，就算失效。</p><p>先<strong>强制缓存（200）</strong>——再对比缓存和指纹缓存（两者有一个失效就算过期）</p><p>那么<strong>问题来了</strong>，这样设置时，在强制缓存下，缓存没过期时，服务器端更改了文件，客户端不一样拿不到最新的文件吗。</p><p>我们所说的缓存多用于静态资源和图片（static文件夹），对于经常改编的js逻辑，在正式生产环境打包时，会生成不同的hash值。</p><p>由于index.html文件不会被缓存，所以该文件中引入的js文件即时打包生成带有最新的hash值的js。所以请求会指向新的URI，不会走缓存。</p><h3 id="常见问题总结"><a href="#常见问题总结" class="headerlink" title="常见问题总结"></a>常见问题总结</h3><ol><li><p>缓存设置操作只能在服务器端进行，客户端浏览器能做什么？</p><p>前端并不能做什么。缓存这件事，让服务器端去搞。</p></li><li>首页index.html即使没有加hash戳也是不会被缓存的，防止出现断网时仍能访问页面的情况</li><li>浏览器network上，有一个小按钮，可以禁用所有缓存</li><li>关于 <code>Cache-Control</code> 响应头的值，当服务器设置为 <code>no-cache</code> 时，代表每次请求会都访问服务器，但是也会走缓存。当值为 <code>no-store</code> 才表示所有的请求，都不会走缓存</li><li>在进行指纹缓存时，node服务器端多使用 <code>Crypto</code> 第三方模块</li><li><p>服务器端设置各种响应头标识（<code>Last-Modified等</code>）当前文件最新状态，那客户端浏览器第二次发给服务器时，需要手动把这个标识设置到请求头吗？</p><p>不需要，浏览器会携带</p></li></ol><p><img src="/assets/images/性能优化—http.png" alt="http"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍压缩、缓存是如何实现的。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="面试" scheme="http://www.zbwblog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="http" scheme="http://www.zbwblog.com/tags/http/"/>
    
      <category term="性能优化" scheme="http://www.zbwblog.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="压缩" scheme="http://www.zbwblog.com/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="缓存" scheme="http://www.zbwblog.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>图片资源相关</title>
    <link href="http://www.zbwblog.com/2019/09/28/%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E7%9B%B8%E5%85%B3/"/>
    <id>http://www.zbwblog.com/2019/09/28/图片资源相关/</id>
    <published>2019-09-28T05:33:00.000Z</published>
    <updated>2019-10-01T04:56:46.636Z</updated>
    
    <content type="html"><![CDATA[<p>介绍图片文件资源。<br>实际开发中，如何正确处理图片资源。<br><a id="more"></a><br><!-- toc --></p><h2 id="与图片相关的数据类型有哪些"><a href="#与图片相关的数据类型有哪些" class="headerlink" title="与图片相关的数据类型有哪些"></a>与图片相关的数据类型有哪些</h2><ol><li>image对象（js）=&gt; appendTo Body =&gt; img元素（dom）</li><li>dataUrl（base64、url）</li><li>file(基于blob)文件对象</li><li>canvas对象</li></ol><h2 id="图片各种数据类型间转换"><a href="#图片各种数据类型间转换" class="headerlink" title="图片各种数据类型间转换"></a>图片各种数据类型间转换</h2><p><img src="/assets/images/各种图片数据类型互转.png" alt="环境区分"></p><h2 id="src属性值可以是哪些"><a href="#src属性值可以是哪些" class="headerlink" title="src属性值可以是哪些"></a>src属性值可以是哪些</h2><ol><li>url地址</li><li>base64</li></ol><h2 id="获取图片宽高等数据"><a href="#获取图片宽高等数据" class="headerlink" title="获取图片宽高等数据"></a>获取图片宽高等数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片对象读取完毕后即可获取图片相关属性</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> width = <span class="keyword">this</span>.width</span><br><span class="line">  <span class="keyword">const</span> height = <span class="keyword">this</span>.height</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">'xxxxxxxx'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍图片文件资源。&lt;br&gt;实际开发中，如何正确处理图片资源。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="图片" scheme="http://www.zbwblog.com/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="文件资源" scheme="http://www.zbwblog.com/tags/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>使用vue-cli3</title>
    <link href="http://www.zbwblog.com/2019/09/28/%E4%BD%BF%E7%94%A8vue-cli3/"/>
    <id>http://www.zbwblog.com/2019/09/28/使用vue-cli3/</id>
    <published>2019-09-28T04:33:00.000Z</published>
    <updated>2019-10-01T04:58:29.203Z</updated>
    
    <content type="html"><![CDATA[<p>介绍vue-cli3在常见场景下的使用。<br><a id="more"></a><br><!-- toc --></p><h2 id="修改webpack配置"><a href="#修改webpack配置" class="headerlink" title="修改webpack配置"></a>修改webpack配置</h2><h3 id="chainWebpack选项"><a href="#chainWebpack选项" class="headerlink" title="chainWebpack选项"></a>chainWebpack选项</h3><p>chainWebpack 配置项允许我们更细粒度的控制 webpack 的内部配置，其集成的是 webpack-chain 这一插件，该插件可以让我们能够使用链式操作来修改配置</p><h3 id="configureWebpack选项"><a href="#configureWebpack选项" class="headerlink" title="configureWebpack选项"></a>configureWebpack选项</h3><p>configureWebpack 更倾向于整体替换和修改，该选项可以是一个对象或者函数。</p><p>当为对象时，实际上使用 <code>webpack-merge</code> 插件与原有配置进行合并。</p><p>当为函数时，可以直接使用其 config 参数来修改 webpack 中的配置。此时该函数也可以返回一个对象，与原有配置进行合并操作。</p><h2 id="生产环境sourceMap功能"><a href="#生产环境sourceMap功能" class="headerlink" title="生产环境sourceMap功能"></a>生产环境sourceMap功能</h2><p><code>productionSourceMap</code> 控制生产环境是否开启 <code>sourceMap</code> 功能。开启后，在生产环境中，代码报错时，易于调试，同时会暴露应用源代码</p><h2 id="为本项目增加二级目录"><a href="#为本项目增加二级目录" class="headerlink" title="为本项目增加二级目录"></a>为本项目增加二级目录</h2><p>如果你想要将项目地址加一个二级目录，比如：<code>http://localhost:8080/vue/</code>，那么我们需要在 <code>vue.config.js</code> 里配置 <code>baseurl</code> 这一项。</p><p>其改变的其实是 webpack 配置文件中 output 的 publicPath 项，这时候你重启终端再次打开页面的时候我们首页的 url 就会变成带二级目录的形式。</p><h2 id="区分本地、开发、生产环境"><a href="#区分本地、开发、生产环境" class="headerlink" title="区分本地、开发、生产环境"></a>区分本地、开发、生产环境</h2><p>摘自：<a href="https://juejin.im/book/5b23a5aef265da59716fda09/section/5b291904f265da597f1c74ea" target="_blank" rel="noopener">掘金小册-vue项目搭建与开发入门</a></p><h3 id="通过在不同的环境下注入不同标识区分环境"><a href="#通过在不同的环境下注入不同标识区分环境" class="headerlink" title="通过在不同的环境下注入不同标识区分环境"></a>通过在不同的环境下注入不同标识区分环境</h3><p>我们可以在根目录下创建以下形式的文件进行不同环境下变量的配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.env                # 在所有的环境中被载入</span><br><span class="line">.env.local          # 在所有的环境中被载入，但会被 git 忽略</span><br><span class="line">.env.[mode]         # 只在指定的模式中被载入</span><br><span class="line">.env.[mode].local   # 只在指定的模式中被载入，但会被 git 忽略</span><br></pre></td></tr></table></figure><p>比如我们创建一个名为 .env.stage 的文件，该文件表明其只在 stage 环境下被加载，在这个文件中，我们可以配置如下键值对的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=stage</span><br><span class="line">VUE_APP_TITLE=stage mode</span><br></pre></td></tr></table></figure><p>这时候我们怎么在 vue.config.js 中访问这些变量呢？很简单，使用 process.env.[name] 进行访问就可以了，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// development（在终端输出）</span></span><br></pre></td></tr></table></figure><p>当你运行 yarn serve 命令后会发现输出的是 development，因为 vue-cli-service serve 命令默认设置的环境是 development，你需要修改 package.json 中的 serve 脚本的命令为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"serve"</span>: <span class="string">"vue-cli-service serve --mode stage"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>--mode stage</code> 其实就是修改了 webpack 4 中的 mode 配置项为 stage，同时其会读取对应 <code>.env.[model]</code> 文件下的配置，如果没找到对应配置文件，其会使用默认环境 development，同样 vue-cli-service build 会使用默认环境 production。</p><p>这时候如果你再创建一个 .env 的文件，再次配置重复的变量，但是值不同，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=staging</span><br><span class="line">VUE_APP_TITLE=staging mode</span><br><span class="line">VUE_APP_NAME=project</span><br></pre></td></tr></table></figure><p>因为 .env 文件会被所有环境加载，即公共配置，那么最终我们运行 vue-cli-service serve 打印出来的是哪个呢？答案是 stage，但是如果是 .env.stage.local 文件中配置成上方这样，答案便是 staging，所以 .env.[mode].local 会覆盖 .env.[mode] 下的相同配置。同理 .env.local 会覆盖 .env 下的相同配置。</p><p>由此可以得出结论，相同配置项的权重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.env.[mode].local &gt; .env.[mode] &gt; .env.local &gt; .env</span><br></pre></td></tr></table></figure><p>但是需要注意的是，除了相同配置项权重大的覆盖小的，不同配置项它们会进行合并操作，类似于 Javascript 中的 Object.assign 的用法。</p><h3 id="如何在客户端侧区分环境"><a href="#如何在客户端侧区分环境" class="headerlink" title="如何在客户端侧区分环境"></a>如何在客户端侧区分环境</h3><p>通过上述配置文件的创建，我们成功使用命令行的形式对项目环境进行了设置并可以自由切换，但是需要注意的是我们在 Vue 的前端代码中打印出的 process.env 与 vue.config.js 中输出的可能是不一样的，这需要普及一个知识点：webpack 通过 DefinePlugin 内置插件将 process.env 注入到客户端代码中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack 配置</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            <span class="string">'process.env'</span>: &#123;</span><br><span class="line">                NODE_ENV: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 vue-cli 3.x 封装的 webpack 配置中已经帮我们完成了这个功能，所以我们可以直接在客户端代码中打印出 process.env 的值，该对象可以包含多个键值对，也就是说可以注入多个值，但是经过 CLI 封装后仅支持注入环境配置文件中以 VUE_APP_ 开头的变量，而 NODE_ENV 和 BASE_URL 这两个特殊变量除外。比如我们在权重最高的 .env.stage.local 文件中写入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=stage2</span><br><span class="line">VUE_APP_TITLE=stage mode2</span><br><span class="line">NAME=vue</span><br></pre></td></tr></table></figure><p>然后我们尝试在 vue.config.js 中打印 process.env，终端输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    npm_config_ignore_scripts: <span class="string">''</span>,</span><br><span class="line">    npm_config_version_git_sign: <span class="string">''</span>,</span><br><span class="line">    npm_config_ignore_optional: <span class="string">''</span>,</span><br><span class="line">    npm_config_init_version: <span class="string">'1.0.0'</span>,</span><br><span class="line">    npm_package_dependencies_vue_router: <span class="string">'^3.0.1'</span>,</span><br><span class="line">    npm_config_version_tag_prefix: <span class="string">'v'</span>,</span><br><span class="line">    npm_node_execpath: <span class="string">'/usr/local/bin/node'</span>,</span><br><span class="line">    NODE_ENV: <span class="string">'stage2'</span>,</span><br><span class="line">    VUE_APP_TITLE: <span class="string">'stage mode2'</span>,</span><br><span class="line">    NAME: <span class="string">'vue'</span>,</span><br><span class="line">    BABEL_ENV: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出内容除了我们环境配置中的变量外还包含了很多 npm 的信息，但是我们在入口文件 main.js <strong>客户端侧代码</strong>中打印会发现输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"BASE_URL"</span>: <span class="string">"/vue/"</span>,</span><br><span class="line">    <span class="string">"NODE_ENV"</span>: <span class="string">"stage2"</span>,</span><br><span class="line">    <span class="string">"VUE_APP_TITLE"</span>: <span class="string">"stage mode2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见注入时过滤调了非 VUE_APP_ 开头的变量，其中多出的 BASE_URL 为你在 vue.config.js 设置的值，默认为 /，其在环境配置文件中设置无效。</p><p><img src="/assets/images/环境区分1.jpg" alt="环境区分"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍vue-cli3在常见场景下的使用。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="vue" scheme="http://www.zbwblog.com/tags/vue/"/>
    
      <category term="脚手架" scheme="http://www.zbwblog.com/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    
      <category term="vue-cli3" scheme="http://www.zbwblog.com/tags/vue-cli3/"/>
    
  </entry>
  
  <entry>
    <title>关于package.json配置项</title>
    <link href="http://www.zbwblog.com/2019/09/25/%E5%85%B3%E4%BA%8Epackage.json/"/>
    <id>http://www.zbwblog.com/2019/09/25/关于package.json/</id>
    <published>2019-09-25T14:11:00.000Z</published>
    <updated>2019-10-01T04:38:26.126Z</updated>
    
    <content type="html"><![CDATA[<p>解读package.json配置项。<br><a id="more"></a><br><!-- toc --></p><h2 id="browserslist配置项"><a href="#browserslist配置项" class="headerlink" title="browserslist配置项"></a>browserslist配置项</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>browserslist是package.json包描述文件中的一个配置项，用于配置浏览器类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"browserslist"</span>: [</span><br><span class="line">    <span class="string">"&gt; 1%"</span>, <span class="comment">// 表示包含所有使用率 &gt; 1% 的浏览器</span></span><br><span class="line">    <span class="string">"last 2 versions"</span>, <span class="comment">// 表示包含浏览器最新的两个版本</span></span><br><span class="line">    <span class="string">"not ie &lt;= 8"</span> <span class="comment">// 表示不包含 ie8 及以下版本</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="为什么会存在"><a href="#为什么会存在" class="headerlink" title="为什么会存在"></a>为什么会存在</h3><p>主要作用是用于在不同的前端工具之间共享目标浏览器和 Node.js 的版本</p><p>比如像 autoprefixer 这样的插件需要把你写的 css 样式适配不同的浏览器，那么这里要针对哪些浏览器呢，就是上面配置中所包含的。</p><p>而如果写在 autoprefixer 的配置中，那么会存在一个问题，万一其他第三方插件也需要浏览器的包含范围用于实现其特定的功能，那么就又得在其配置中设置一遍，这样就无法得以共用。所以在 package.json 中配置 browserslist 的属性使得所有工具都会自动找到目标浏览器。</p><p>当然，你也可以单独写在 .browserslistrc 的文件中：</p><p>至于它是如何去衡量浏览器的使用率和版本的，数据都是来源于 Can I Use。你也可以访问 browserl.ist/ 去搜索配置项所包含的浏览器列表，比如搜索 last 2 versions 会得到你想要的结果，或者在项目终端运行如下命令查看：</p><h3 id="有哪些应用场景"><a href="#有哪些应用场景" class="headerlink" title="有哪些应用场景"></a>有哪些应用场景</h3><p>autoprefixer、babel、postcss</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解读package.json配置项。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="npm" scheme="http://www.zbwblog.com/tags/npm/"/>
    
      <category term="node" scheme="http://www.zbwblog.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>关于webpack配置常见问题</title>
    <link href="http://www.zbwblog.com/2019/09/24/%E5%85%B3%E4%BA%8Ewebpack%E9%85%8D%E7%BD%AE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://www.zbwblog.com/2019/09/24/关于webpack配置常见问题/</id>
    <published>2019-09-24T15:01:00.000Z</published>
    <updated>2019-10-01T04:59:21.040Z</updated>
    
    <content type="html"><![CDATA[<p>总结配置webpack时常见的问题。<br><a id="more"></a><br><!-- toc --></p><h2 id="源码暴露"><a href="#源码暴露" class="headerlink" title="源码暴露"></a>源码暴露</h2><p>项目发布上线后，在控制台source选项中的webpack://文件夹中可以看到项目源码问题</p><p><img src="/assets/images/源码暴露.jpg" alt="源码暴露"></p><p>解决方案</p><p>关闭webpack中的sourceMap功能，即 <code>devtool</code> 选项</p><p>vue-cli3中，则许关闭vue.config.js中的 <code>productionSourceMap</code> 配置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结配置webpack时常见的问题。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="自动化构建" scheme="http://www.zbwblog.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/"/>
    
      <category term="前端工程化" scheme="http://www.zbwblog.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="http://www.zbwblog.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue项目搭建</title>
    <link href="http://www.zbwblog.com/2019/09/24/vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.zbwblog.com/2019/09/24/vue项目搭建/</id>
    <published>2019-09-24T15:01:00.000Z</published>
    <updated>2019-10-01T04:56:46.638Z</updated>
    
    <content type="html"><![CDATA[<p>从0搭建一个vue项目，你需要知道哪些东西。<br><a id="more"></a><br><!-- toc --></p><h2 id="搭建模板"><a href="#搭建模板" class="headerlink" title="搭建模板"></a>搭建模板</h2><p><a href="https://juejin.im/book/5b23a5aef265da59716fda09" target="_blank" rel="noopener">掘金小册——Vue 项目构建与开发入门</a></p><p><img src="/assets/images/vue单页应用基础配置.jpg" alt="环境区分"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从0搭建一个vue项目，你需要知道哪些东西。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="vue" scheme="http://www.zbwblog.com/tags/vue/"/>
    
      <category term="项目架构" scheme="http://www.zbwblog.com/tags/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ajax交互数据格式</title>
    <link href="http://www.zbwblog.com/2019/09/23/ajax%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"/>
    <id>http://www.zbwblog.com/2019/09/23/ajax交互数据格式/</id>
    <published>2019-09-23T14:05:00.000Z</published>
    <updated>2019-10-01T04:33:32.726Z</updated>
    
    <content type="html"><![CDATA[<p>总结前后端常用数据交互格式。<br><a id="more"></a><br><!-- toc --></p><h2 id="表单格式"><a href="#表单格式" class="headerlink" title="表单格式"></a>表单格式</h2><p><code>content-type:application/x-www-form-urlencoded</code></p><p>格式为：<a href="mailto:`name=zbw&amp;sex=1&amp;email=569119225@qq.com" target="_blank" rel="noopener">`name=zbw&amp;sex=1&amp;email=569119225@qq.com</a>` 字符串</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'/api/entrance/login'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">'email=xxxx&amp;password=xxxxx&amp;verifyCode=344&amp;key=123'</span></span><br><span class="line"></span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"></span><br><span class="line">xhr.send(data)</span><br></pre></td></tr></table></figure><h2 id="formData格式"><a href="#formData格式" class="headerlink" title="formData格式"></a>formData格式</h2><p><code>content-type:multipart/form-data</code></p><p>一般用于传输文件、图片。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> FormData()</span><br><span class="line">data.append(<span class="string">'srcId'</span>, <span class="number">2</span>)</span><br><span class="line">data.append(<span class="string">'uId'</span>, uId)</span><br><span class="line">data.append(<span class="string">'envId'</span>, envId)</span><br><span class="line">data.append(<span class="string">'cntrId'</span>, cntrId)</span><br><span class="line">data.append(<span class="string">'dataJson'</span>, <span class="built_in">JSON</span>.stringify(dataJson))</span><br><span class="line"></span><br><span class="line">axios.post(</span><br><span class="line">  url,</span><br><span class="line">  data,</span><br><span class="line">  &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="json格式"><a href="#json格式" class="headerlink" title="json格式"></a>json格式</h2><p><code>content-type:application/json</code></p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">axios.post(</span><br><span class="line">  url,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'zbw'</span>,</span><br><span class="line">    sex: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结前后端常用数据交互格式。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="http" scheme="http://www.zbwblog.com/tags/http/"/>
    
      <category term="ajax" scheme="http://www.zbwblog.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>使用gulp构建一个模板项目</title>
    <link href="http://www.zbwblog.com/2019/09/22/%E4%BD%BF%E7%94%A8gulp%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE/"/>
    <id>http://www.zbwblog.com/2019/09/22/使用gulp构建一个模板项目/</id>
    <published>2019-09-22T15:49:00.000Z</published>
    <updated>2019-10-01T04:33:32.728Z</updated>
    
    <content type="html"><![CDATA[<p>使用gulp从0搭建一个简单的应用模板项目。<br>包括：压缩混淆js、处理es6语法、css预处理、解决跨域问题等。<br><a id="more"></a><br><!-- toc --></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>使用gulp从零构建一个登录页面</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><code>npm init -y</code></li><li><p><code>git init</code> 建立git仓库</p><p>设置 <code>.gitignore</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">.idea</span><br></pre></td></tr></table></figure></li><li><p>安装gulp</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --global gulp-cli</span><br><span class="line"></span><br><span class="line">npm i -D gulp</span><br></pre></td></tr></table></figure></li><li><p>创建一个简单的gulpfile</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; series, src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> src(<span class="string">'src/**/*.js'</span>)</span><br><span class="line">         .pipe(dest(<span class="string">'dist'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.default = series(jsTask);</span><br></pre></td></tr></table></figure></li></ol><h2 id="gulp命令"><a href="#gulp命令" class="headerlink" title="gulp命令"></a>gulp命令</h2><ol><li><p>查看帮助</p><p><code>gulp -h</code></p></li><li><p>查看所有任务</p><p><code>gulp --tasks</code></p></li><li><p>执行任务</p><p><code>gulp [任务名称]</code></p></li></ol><h2 id="gulp插件"><a href="#gulp插件" class="headerlink" title="gulp插件"></a>gulp插件</h2><h3 id="删除dist目录"><a href="#删除dist目录" class="headerlink" title="删除dist目录"></a>删除dist目录</h3><p><code>npm i -D del</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanTask</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">  del.sync(<span class="string">'dist'</span>)</span><br><span class="line">    done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩、混淆"><a href="#压缩、混淆" class="headerlink" title="压缩、混淆"></a>压缩、混淆</h3><p><code>npm i -D gulp-uglify</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"></span><br><span class="line"> .pipe(uglify())  <span class="comment">// 压缩、混淆</span></span><br></pre></td></tr></table></figure><h3 id="使用es6"><a href="#使用es6" class="headerlink" title="使用es6"></a>使用es6</h3><p><code>npm i -D @babel/core @babel/preset-env gulp-babel</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"></span><br><span class="line"> .pipe(babel(&#123;</span><br><span class="line">            presets: [<span class="string">'@babel/env'</span>]</span><br><span class="line">          &#125;))</span><br></pre></td></tr></table></figure><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p><code>npm i -D gulp-rename</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rename = <span class="built_in">require</span>(<span class="string">"gulp-rename"</span>);</span><br><span class="line"></span><br><span class="line">.pipe(rename(<span class="string">'zbw.js'</span>))</span><br><span class="line"></span><br><span class="line">.pipe(rename(<span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">    path.dirname += <span class="string">"/ciao"</span>;</span><br><span class="line">    path.basename += <span class="string">"-goodbye"</span>;</span><br><span class="line">    path.extname = <span class="string">".md"</span>;</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">.pipe(rename(&#123;</span><br><span class="line">    dirname: <span class="string">"main/text/ciao"</span>,</span><br><span class="line">    basename: <span class="string">"aloha"</span>,</span><br><span class="line">    prefix: <span class="string">"bonjour-"</span>,</span><br><span class="line">    suffix: <span class="string">"-hola"</span>,</span><br><span class="line">    extname: <span class="string">".md"</span></span><br><span class="line">  &#125;))</span><br></pre></td></tr></table></figure><h3 id="合并多文件，输出单一文件"><a href="#合并多文件，输出单一文件" class="headerlink" title="合并多文件，输出单一文件"></a>合并多文件，输出单一文件</h3><p><code>npm i -D gulp-concat</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> concat = <span class="built_in">require</span>(<span class="string">"gulp-concat"</span>);</span><br><span class="line"></span><br><span class="line"> .pipe(concat(<span class="string">'all.js'</span>))</span><br></pre></td></tr></table></figure><h3 id="处理css浏览器兼容性前缀"><a href="#处理css浏览器兼容性前缀" class="headerlink" title="处理css浏览器兼容性前缀"></a>处理css浏览器兼容性前缀</h3><p><code>npm i -D gulp-autoprefixer</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>);</span><br><span class="line"></span><br><span class="line"> .pipe(autoprefixer(&#123;</span><br><span class="line">            cascade: <span class="literal">false</span>,</span><br><span class="line">            remove: <span class="literal">false</span> <span class="comment">// 删除过时的prefixer</span></span><br><span class="line">          &#125;))</span><br><span class="line"></span><br><span class="line"> <span class="string">"browserslist"</span>: [</span><br><span class="line">    <span class="string">"last 2 version"</span>,</span><br><span class="line">    <span class="string">"&gt; 2%"</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h3 id="处理sass，编译压缩"><a href="#处理sass，编译压缩" class="headerlink" title="处理sass，编译压缩"></a>处理sass，编译压缩</h3><p><code>npm i -D gulp-sass</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"></span><br><span class="line">.pipe(sass(&#123;</span><br><span class="line">          outputStyle: <span class="string">'compressed'</span></span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure><h3 id="起一个本地服务，开始调接口吧"><a href="#起一个本地服务，开始调接口吧" class="headerlink" title="起一个本地服务，开始调接口吧"></a>起一个本地服务，开始调接口吧</h3><h4 id="browser-sync"><a href="#browser-sync" class="headerlink" title="browser-sync"></a>browser-sync</h4><p><code>npm i -D browser-sync</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browserSync = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>).create();</span><br><span class="line"><span class="keyword">const</span> reload = browserSync.reload;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在js任务后</span></span><br><span class="line">.pipe(dest(<span class="string">'./dist/js/'</span>))  <span class="comment">// 输出到根目录下dist文件夹</span></span><br><span class="line">.pipe(reload(&#123; <span class="attr">stream</span>: <span class="literal">true</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在css任务后</span></span><br><span class="line">.pipe(dest(<span class="string">'./dist'</span>))</span><br><span class="line">.pipe(reload(&#123; <span class="attr">stream</span>: <span class="literal">true</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">server</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">  browserSync.init(&#123;</span><br><span class="line">    server: &#123;</span><br><span class="line">      baseDir: <span class="string">'./'</span>  <span class="comment">// 指定根目录</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildTask = series([cleanTask, jsTask, cssTask, server, watcherTask])</span><br><span class="line"></span><br><span class="line">exports.default = buildTask;</span><br></pre></td></tr></table></figure><h4 id="gulp-connect-http-proxy-middleware"><a href="#gulp-connect-http-proxy-middleware" class="headerlink" title="gulp-connect + http-proxy-middleware"></a>gulp-connect + http-proxy-middleware</h4><p><code>gulp-connect</code> 用来起服务，配合 <code>http-proxy-middleware</code> 做代理，解决跨域问题</p><p><code>npm i -D gulp-connect http-proxy-middleware</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> connect = <span class="built_in">require</span>(<span class="string">'gulp-connect'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 起服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serverTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  connect.server(&#123;</span><br><span class="line">    root: <span class="string">'./dist'</span>,</span><br><span class="line">    port: <span class="number">8888</span>,</span><br><span class="line">    livereload: <span class="literal">true</span>,</span><br><span class="line">    middleware: <span class="function"><span class="keyword">function</span>(<span class="params">connect, opt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            proxy(<span class="string">'/api/'</span>,  &#123;</span><br><span class="line">                target: <span class="string">'https://devtk.aibeike.com'</span>,</span><br><span class="line">                changeOrigin:<span class="literal">true</span>,</span><br><span class="line">                pathRewrite: &#123;  <span class="comment">// 覆写路径</span></span><br><span class="line">                  <span class="string">'^/api/'</span>: <span class="string">''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 处理html任务</span></span><br><span class="line"><span class="comment"> * @returns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">'src/index.html'</span>)</span><br><span class="line">          .pipe(dest(<span class="string">'dist'</span>))</span><br><span class="line">          .pipe(connect.reload()) <span class="comment">// reload解决热加载问题，js和css资源同理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// serverTask任务和watcherTask任务要并行处理，否则执行到serverTask服务器启动后，任务就自动关闭了，热加载功能会丢失</span></span><br><span class="line"><span class="keyword">const</span> assetsTask = series(cleanTask, htmlTask, jsTask, cssTask, serverTask)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildTask = parallel(assetsTask, watcherTask)</span><br><span class="line"></span><br><span class="line">exports.default = buildTask;</span><br></pre></td></tr></table></figure><h4 id="browser-sync-与-gulp-connect-区别"><a href="#browser-sync-与-gulp-connect-区别" class="headerlink" title="browser-sync 与 gulp-connect 区别"></a>browser-sync 与 gulp-connect 区别</h4><p><code>browser-sync</code> 没有配合使用的代理插件，在解决跨域问题有些鸡肋</p><p><code>gulp-connect</code> 配合 <code>http-proxy-middleware</code> 使用可以很方便的解决跨域问题</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="return-和-done-有什么区别"><a href="#return-和-done-有什么区别" class="headerlink" title="return 和 done() 有什么区别"></a>return 和 done() 有什么区别</h3><p>return 是当返回promise时</p><p>done回调方法比较通用，比如热刷新reload时，return就不好使了</p><h3 id="为什么热刷新不好使"><a href="#为什么热刷新不好使" class="headerlink" title="为什么热刷新不好使"></a>为什么热刷新不好使</h3><p>这段代码不可以写成return，只能写成done</p><h3 id="做代理解决跨域问题时，遇到404问题"><a href="#做代理解决跨域问题时，遇到404问题" class="headerlink" title="做代理解决跨域问题时，遇到404问题"></a>做代理解决跨域问题时，遇到404问题</h3><p>遇到404的一种很常见的情况是，在proxy时，使用了 <code>/api</code> 作为请求接口的前缀链接，但是真正的接口地址中是不存在 <code>/api</code> 这样的路径的，此处需要使用 <code>pathRewrite</code> 覆写删除 <code>/api</code>。</p><p>同样的问题，参考资料：<a href="https://ymbo.github.io/2018/01/09/http-proxy-middleware%E9%85%8D%E5%90%88gulp%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/" target="_blank" rel="noopener">http-proxy-middleware配合gulp使用时的一些坑</a></p><h3 id="为什么引入第三方依赖包如jquery后，源代码找不到"><a href="#为什么引入第三方依赖包如jquery后，源代码找不到" class="headerlink" title="为什么引入第三方依赖包如jquery后，源代码找不到$"></a>为什么引入第三方依赖包如jquery后，源代码找不到$</h3><p>处理js资源时，src方法读取js文件的顺序是有要求的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 处理js任务</span></span><br><span class="line"><span class="comment"> * @returns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 读取src文件夹下所有js文件</span></span><br><span class="line">  <span class="comment">// 注意js文件打包引入的先后顺序，先导入lib，再导入应用代码</span></span><br><span class="line">  <span class="keyword">return</span> src([<span class="string">'src/lib/*.js'</span>, <span class="string">'src/js/*.js'</span>])</span><br><span class="line">          .pipe(babel(&#123; <span class="comment">// 编译es6</span></span><br><span class="line">            presets: [<span class="string">'@babel/env'</span>]</span><br><span class="line">          &#125;))</span><br><span class="line">          .pipe(uglify())  <span class="comment">// 压缩、混淆</span></span><br><span class="line">          .pipe(concat(<span class="string">'bundle.js'</span>)) <span class="comment">// 合并所有文件，输出all.js文件</span></span><br><span class="line">          <span class="comment">// .pipe(rename('bundle.js')) // 重命名为zbw.js</span></span><br><span class="line">          .pipe(dest(<span class="string">'./dist/js/'</span>))  <span class="comment">// 输出到根目录下dist文件夹</span></span><br><span class="line">          .pipe(connect.reload()) <span class="comment">// 热加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用gulp从0搭建一个简单的应用模板项目。&lt;br&gt;包括：压缩混淆js、处理es6语法、css预处理、解决跨域问题等。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="gulp" scheme="http://www.zbwblog.com/tags/gulp/"/>
    
      <category term="自动化构建" scheme="http://www.zbwblog.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/"/>
    
      <category term="前端工程化" scheme="http://www.zbwblog.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>图片上传阿里云后被自动旋转问题</title>
    <link href="http://www.zbwblog.com/2019/09/22/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%90%8E%E8%A2%AB%E6%97%8B%E8%BD%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://www.zbwblog.com/2019/09/22/图片上传后被旋转问题/</id>
    <published>2019-09-22T09:22:00.000Z</published>
    <updated>2019-10-01T04:56:46.630Z</updated>
    
    <content type="html"><![CDATA[<p>你知道EXIF是什么吗？<br><a id="more"></a><br><!-- toc --></p><!-- TOC --><ul><li><a href="#背景">背景</a></li><li><a href="#产生问题原因">产生问题原因</a></li><li><a href="#exif信息">EXIF信息</a></li><li><a href="#如何解决">如何解决</a><ul><li><a href="#方法一阿里云官方解决方案">方法一：阿里云官方解决方案</a></li><li><a href="#方法二修改图像元数据">方法二：修改图像元数据</a><ul><li><a href="#代码示例">代码示例</a></li></ul></li></ul></li><li><a href="#参考资料">参考资料</a></li></ul><!-- /TOC --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>开发移动端应用，使用原生 <code>file</code> 标签开发上传图片功能时，发现部分安卓手机，上传图片到阿里云成功后，使用返回的url回显插入到dom中时被莫名其妙地逆时针旋转了90度。</p><h2 id="产生问题原因"><a href="#产生问题原因" class="headerlink" title="产生问题原因"></a>产生问题原因</h2><p>一般通过手机或者倒置相机等方式拍出来的照片其实已经旋转，带有旋转参数。但是在图片查看器、浏览器中打开会对旋转参数的图片进行处理，所以我们看到的图片是正的。</p><h2 id="EXIF信息"><a href="#EXIF信息" class="headerlink" title="EXIF信息"></a>EXIF信息</h2><p>EXIF是专门为数码相机的照片设定，可以记录数码照片的属性信息和拍摄数据。</p><p>手机在拍照生成图片时，也会生成图片EXIF信息，我们称之为元数据。</p><p>所谓元数据，是用于描述数据的数据（信息）。</p><p>元数据中的 <code>Orientation</code> 属性即旋转参数，标识图片被旋转了多少度。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><h3 id="方法一：阿里云官方解决方案"><a href="#方法一：阿里云官方解决方案" class="headerlink" title="方法一：阿里云官方解决方案"></a>方法一：阿里云官方解决方案</h3><p><a href="https://help.aliyun.com/document_detail/44691.html?spm=a2c4g.11186623.6.1245.720c3091TC4Rv9" target="_blank" rel="noopener">阿里云官方解决方案</a></p><h3 id="方法二：修改图像元数据"><a href="#方法二：修改图像元数据" class="headerlink" title="方法二：修改图像元数据"></a>方法二：修改图像元数据</h3><p>解决思路是在上传阿里云逻辑之前，使用适配器模式，加一层适配逻辑。把被旋转过的file对象，转化成正常的file对象，再继续传阿里云。</p><ol><li>使用 <code>exif-js</code> 库获取图片元数据中的 <code>Orientation</code> 参数</li><li><p>根据参数判断图片是否需要旋转处理</p><p><code>Orientation</code> 值为 <code>undefined</code> 或 <code>0</code> 或 <code>1</code>  时，表示生成图片没有被旋转，因此不需要做额外的旋转处理</p></li><li><p>拿到 <code>file</code> 类型数据，使用 <code>fileReader</code> 转换成 <code>base64</code></p></li><li>在内存中创建image元素，读取 <code>base64</code> 生成img元素</li><li>在 <code>img</code> 元素 <code>onload</code> 时，使用 <code>canvas</code> 绘制图像</li><li>根据 <code>Orientation</code> 旋转 <code>canvas</code> 图层到正确的方向</li><li>将 <code>canvas</code> 对象转化为 <code>blob</code> 对象</li><li>将 <code>blob</code> 对象转化为 <code>file</code> 对象</li><li>回到上传阿里云的操作</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: zbw</span></span><br><span class="line"><span class="comment"> * @Date: 2019-09-19 18:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> EXIF <span class="keyword">from</span> <span class="string">'exif-js'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileToDataURL</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">      reader.onloadend = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        resolve(e.target.result)</span><br><span class="line">      &#125;</span><br><span class="line">      reader.readAsDataURL(file)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canvasResizetoFile</span> (<span class="params">canvas, quality = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    canvas.toBlob(<span class="function"><span class="keyword">function</span> (<span class="params">blob</span>) </span>&#123;</span><br><span class="line">      resolve(blob)</span><br><span class="line">    &#125;, <span class="string">'image/jpeg'</span>, quality)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blobToFile</span> (<span class="params">theBlob, fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">window</span>.File([theBlob], fileName, &#123;<span class="attr">type</span>: theBlob.type&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOrientation</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> orientation = <span class="number">0</span></span><br><span class="line">      EXIF.getData(file, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        orientation = EXIF.getTag(<span class="keyword">this</span>, <span class="string">'Orientation'</span>)</span><br><span class="line">        resolve(orientation)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理图片EXIF元数据</span></span><br><span class="line"><span class="comment"> * @param file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleEXIF</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 从图片元数据中读取旋转标识</span></span><br><span class="line">      <span class="keyword">const</span> orientation = <span class="keyword">await</span> getOrientation(file)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 正常未被旋转的图片orientation值</span></span><br><span class="line">      <span class="keyword">const</span> normalType = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">if</span> (!orientation || normalType.includes(<span class="built_in">Number</span>(orientation))) resolve(file)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果图片元数据中标识图片已经被旋转过了，则重置图片回未旋转状态，兼容同小米6等机型</span></span><br><span class="line">      <span class="keyword">const</span> base64Data = <span class="keyword">await</span> fileToDataURL(file)</span><br><span class="line">      <span class="keyword">let</span> imgTem = <span class="keyword">new</span> Image()</span><br><span class="line">      imgTem.onload = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">        <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">        <span class="keyword">const</span> width = imgTem.width</span><br><span class="line">        <span class="keyword">const</span> height = imgTem.height</span><br><span class="line">        <span class="keyword">const</span> isReverseSize = [<span class="number">6</span>, <span class="number">8</span>].includes(<span class="built_in">Number</span>.parseInt(orientation))</span><br><span class="line">        canvas.width = isReverseSize ? height : width</span><br><span class="line">        canvas.height = isReverseSize ? width : height</span><br><span class="line">        <span class="keyword">switch</span> (orientation) &#123;</span><br><span class="line">          <span class="comment">// 测试代码</span></span><br><span class="line">          <span class="comment">// case 1:</span></span><br><span class="line">          <span class="comment">// case undefined:</span></span><br><span class="line">          <span class="comment">//   ctx.drawImage(imgTem, 0, 0)</span></span><br><span class="line">          <span class="comment">//   break</span></span><br><span class="line">          <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="comment">// 图片顺时针旋转90°</span></span><br><span class="line">            ctx.rotate(<span class="built_in">Math</span>.PI / <span class="number">2</span>)</span><br><span class="line">            ctx.translate(<span class="number">0</span>, -height)</span><br><span class="line">            ctx.drawImage(imgTem, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="comment">// 图片顺时针旋转180°</span></span><br><span class="line">            ctx.rotate(<span class="built_in">Math</span>.PI)</span><br><span class="line">            ctx.translate(-width, -height)</span><br><span class="line">            ctx.drawImage(imgTem, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="comment">// 图片顺时针旋转270°</span></span><br><span class="line">            ctx.rotate(-<span class="built_in">Math</span>.PI / <span class="number">2</span>)</span><br><span class="line">            ctx.translate(-height, <span class="number">0</span>)</span><br><span class="line">            ctx.drawImage(imgTem, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> blob = <span class="keyword">await</span> canvasResizetoFile(canvas)</span><br><span class="line">        <span class="keyword">const</span> fileObj = blobToFile(blob, file.name)</span><br><span class="line">        resolve(fileObj)</span><br><span class="line">      &#125;</span><br><span class="line">      imgTem.src = base64Data</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  handleEXIF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![思维导图/assets/images/images/图片上传后被旋转问题.jpg)</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.mamicode.com/info-detail-2440485.html" target="_blank" rel="noopener">同一问题</a></li><li><a href="https://github.com/exif-js/exif-js" target="_blank" rel="noopener">exif-js</a></li><li><a href="http://code.ciaoca.com/javascript/exif-js/" target="_blank" rel="noopener">Exif.js 读取图像的元数据</a></li><li><a href="https://github.com/WangYuLue/image-conversion" target="_blank" rel="noopener">一个图片数据类型转换库</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" target="_blank" rel="noopener">fileReader-mdn</a></li><li><a href="https://www.cnblogs.com/lwxiao/p/10519617.html" target="_blank" rel="noopener">图片数据类型转换相关1</a></li><li><a href="https://www.jianshu.com/p/5b44c41adfe2" target="_blank" rel="noopener">图片数据类型转换相关2</a></li><li><a href="https://help.aliyun.com/knowledge_detail/39624.html" target="_blank" rel="noopener">如何解决正常原图处理之后为被旋转的问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你知道EXIF是什么吗？&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="阿里云" scheme="http://www.zbwblog.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="OSS上传" scheme="http://www.zbwblog.com/tags/OSS%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="图片" scheme="http://www.zbwblog.com/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="文件资源" scheme="http://www.zbwblog.com/tags/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90/"/>
    
      <category term="移动端" scheme="http://www.zbwblog.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="兼容问题" scheme="http://www.zbwblog.com/tags/%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端监控</title>
    <link href="http://www.zbwblog.com/2019/09/22/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    <id>http://www.zbwblog.com/2019/09/22/前端监控/</id>
    <published>2019-09-22T08:28:00.000Z</published>
    <updated>2019-10-01T05:00:02.439Z</updated>
    
    <content type="html"><![CDATA[<p>介绍前端监控在实际开发中的应用。<br><a id="more"></a><br><!-- toc --></p><h2 id="前端监控是什么"><a href="#前端监控是什么" class="headerlink" title="前端监控是什么"></a>前端监控是什么</h2><p>前端监控主要从以下三个方面监测网站运行时的健康程度。</p><ul><li>页面打开速度</li><li>页面稳定性（js报错）</li><li>外部服务调用成功率（api）</li></ul><h2 id="为什么要有前端监控"><a href="#为什么要有前端监控" class="headerlink" title="为什么要有前端监控"></a>为什么要有前端监控</h2><p>用户访问我们的业务时，整个访问过程大致可以分为三个阶段：页面生产时（Server 端状态）、页面加载时和页面运行时。</p><p>为了保证线上业务稳定运行，我们会在 Server 端对业务的运行状态进行各种监控。现有的 Server 端监控系统相对已经很成熟了，而页面加载和页面运行时的状态监控一直比较欠缺。例如：</p><p>无法第一时间获知用户访问我们的站点时遇到的错误；<br>各个国家、各个地区的用户访问我们站点的真实速度未知；<br>每个应用内有大量的异步数据调用，而它们的性能、成功率都是未知的。</p><h2 id="如何为网站设置前端监控"><a href="#如何为网站设置前端监控" class="headerlink" title="如何为网站设置前端监控"></a>如何为网站设置前端监控</h2><p>申请阿里云账号——购买服务，<a href="https://signin.aliyun.com/1796066747675887/login.htm" target="_blank" rel="noopener">登录</a><br><img src="/assets/images/前端监控1.jpg" alt="前端监控1"><br><img src="/assets/images/前端监控2.jpg" alt="前端监控2"><br><img src="/assets/images/前端监控3.jpg" alt="前端监控3"><br><img src="/assets/images/前端监控4.jpg" alt="前端监控4"></p><h2 id="使用原理"><a href="#使用原理" class="headerlink" title="使用原理"></a>使用原理</h2><p>购买服务后，添加应用，会为你生成一个唯一阿里云监控可以识别 <code>pid</code>, 在应用的js代码中，通过调用cdn公开接口的方式，将pid传给阿里云，阿里云自动帮助网站进行监控。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="环境区分"><a href="#环境区分" class="headerlink" title="环境区分"></a>环境区分</h3><p>我们需要的是线上真实用户的使用数据，因此在项目中，我们需要区分【本地、测试、dev】和【线上】环境，开发时生成两个pid。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  !(<span class="function"><span class="keyword">function</span>(<span class="params">c,b,d,a</span>)</span>&#123;</span><br><span class="line">    c[a]||(c[a]=&#123;&#125;);</span><br><span class="line">    c[a].config=&#123;<span class="attr">pid</span>:<span class="string">"honho8hw4v@29cc205fe71c7c8"</span>,<span class="attr">appType</span>:<span class="string">"web"</span>,<span class="attr">imgUrl</span>:<span class="string">"https://arms-retcode.aliyuncs.com/r.png?"</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>)</span><br><span class="line">    script.setAttribute(<span class="string">"crossorigin"</span>,<span class="string">""</span>)</span><br><span class="line">    script.setAttribute(<span class="string">"src"</span>, d)</span><br><span class="line">    <span class="keyword">const</span> firstChild = <span class="built_in">document</span>.body.firstChild</span><br><span class="line">    b.body.insertBefore(script, firstChild)</span><br><span class="line">  &#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>,<span class="string">"https://retcode.alicdn.com/retcode/bl.js"</span>,<span class="string">"__bl"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://help.aliyun.com/document_detail/58652.html?spm=a2c4g.11186623.6.617.d26b3ddfk41C9a" target="_blank" rel="noopener">阿里云前端监控</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍前端监控在实际开发中的应用。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="前端监控" scheme="http://www.zbwblog.com/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
      <category term="阿里云" scheme="http://www.zbwblog.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>vue实战技巧</title>
    <link href="http://www.zbwblog.com/2019/09/22/vue%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.zbwblog.com/2019/09/22/vue实战技巧/</id>
    <published>2019-09-22T07:52:00.000Z</published>
    <updated>2019-10-01T04:48:11.765Z</updated>
    
    <content type="html"><![CDATA[<p>在vue开发中你不知道的黑科技。<br><a id="more"></a><br><!-- toc --></p><h2 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h2><ol><li><p>是什么？</p><p>是vue中的一种依赖注入的概念api，由父级或祖先级向子级注入数据，子级接收，实现跨越无数层级组件间通讯。</p></li><li><p>为什么存在？</p><p>简化vue跨多层级组件通讯</p><p>开发独立组件时，代替 <code>vuex</code> 在顶层组件管理状态</p></li><li><p>注意</p><p>注入的数据并不是可响应的，这是刻意为之的，并且不能修改，会报错：避免直接改变注入的值（基本数据类型和引用数据类型的地址），因为只要提供的组件重新呈现，更改就会被覆盖。</p><p>但是！ <code>如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</code></p><p> 也就是说引用数据类型的属性是可以改变的，并且可以出发响应式变化，利用这一点，我们可以做很多事情。如利用入口模块向下注入核心数据对象，各子模块接收后粒度化拆分功能修改核心数据对象。</p><p><code>prop</code> 同理，<code>vue</code> 虽然宣扬单向数据流，但是这种类似于 <code>Angular</code> 数据双向绑定概念的操作，拆分核心对象数据到各个粒度化子组件修改，会让你的代码撸到爽到飞起。</p></li><li><p>在哪里可以使用</p><p>父级组件和子级组件产生了一种隐形的耦合关系，父级不知道最终将数据传给谁，子级不知道数据是从哪里获取到的，因此只建议在封闭度高的高阶组件和组件库中使用，不建议在应用代码中使用。</p><p>由于传入的基本类型数据不可响应，更推荐注入对象的形式。常用于初始化项目（组件）使用的配置，比如年部学科，这些东西一般不会发生变化，子组件又不定时需要。最重要的是，不依赖于vuex，因此成为开发独立插件组件的首选。</p></li><li><p>示例</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父级、祖先级组件</span></span><br><span class="line">provide() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    List: <span class="keyword">this</span>.List,</span><br><span class="line">    type: <span class="keyword">this</span>.type</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">inject: &#123;</span><br><span class="line"><span class="comment">// 类型</span></span><br><span class="line">  type: &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">// 列表</span></span><br><span class="line">  list: &#123;</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><ol><li><p>是什么</p><p>在某个位置，动态切换，加载不同的组件。</p></li><li><p>为什么存在</p><p>避免出现大量的 <code>v-if</code> , 更优雅处理业务逻辑。</p></li><li><p>注意</p><p>使用动态组件时，通常会重新创建不同的组件，但是当切换的是同一个组件的时候，如单选题组件和多选题组件，由于公用的是一个组件，vue内部会自动处理，不会再重新创建这个组件，不重新创建组件内的状态就无法清空，引发问题，此时需要加一个key作为唯一标识，保证组件重新创建。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> COMPONENT_CONFIG = &#123;</span><br><span class="line">  [QS_LOGIC_ID_MAP.SINGLE_CHOICE]: <span class="string">'Choice'</span>,</span><br><span class="line">  [QS_LOGIC_ID_MAP.MULTIPLE_CHOICE]: <span class="string">'Choice'</span>,</span><br><span class="line">  [QS_LOGIC_ID_MAP.FILL_BLANKS]: <span class="string">'FillBlank'</span>,</span><br><span class="line">  [QS_LOGIC_ID_MAP.RESOLVE_ANSWER]: <span class="string">'ResolveQs'</span>,</span><br><span class="line">  [QS_LOGIC_ID_MAP.COMPLEX]: <span class="string">'Complex'</span></span><br><span class="line">&#125;</span><br><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 当前逻辑题型</span></span><br><span class="line">  currentLogicId() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mainData.logicQuesTypeId</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当前组件</span></span><br><span class="line">  currentComponent() &#123;</span><br><span class="line">    <span class="keyword">return</span> COMPONENT_CONFIG[<span class="keyword">this</span>.currentLogicId]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&lt;component :is=<span class="string">"currentComponent"</span> :main-data=<span class="string">"mainData"</span> :key=<span class="string">"currentLogicId"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/component&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在哪里可以使用</p><p>如根据不同的题型id，切换不同的录题组件。</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// currentComponent 是已注册组件的名字 或 一个组件的选项对象</span></span><br><span class="line">&lt;component :is=<span class="string">"currentComponent"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>   watch监听值/引用地址的变化</p><h3 id="immediate属性"><a href="#immediate属性" class="headerlink" title="immediate属性"></a>immediate属性</h3><ol><li><p>是什么？</p><p>让所监听数据初次赋值时就触发 <code>handler</code> ，而非纯异步监听：只有改变时才出发 <code>handler</code></p></li><li><p>为什么存在？</p><p>在一些特定的应用场景中，我们试图监听 <code>prop</code> ，而不仅仅是本组件中的状态，但父组件对子组件 <code>prop</code> 的初次赋值我们是监听不到的，所以 <code>immediate</code> 诞生了。</p></li><li><p>在哪里可以使用？</p><p>监听 <code>prop</code></p></li><li><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  mainData: &#123;</span><br><span class="line">    type: <span class="built_in">Object</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  mainData: &#123;</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 保证父组件初始化是对mainData（null）赋值后，子组件立即响应</span></span><br><span class="line">      immediate: <span class="literal">true</span>,</span><br><span class="line">        handler: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.$emit(<span class="string">'update'</span>, <span class="keyword">this</span>.mainData)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="关于控制组件状态"><a href="#关于控制组件状态" class="headerlink" title="关于控制组件状态"></a>关于控制组件状态</h2><ol><li><p>背景</p><p>我们经常说<strong>粒度化</strong>，指将<strong>复杂的功能拆解到不同子模块处理。</strong></p><p>经过使用vue了一段时间后，我们发现，由于父组件prop传进来的<strong>值/引用地址</strong>在<strong>无法在子组件中直接改变</strong>，于是我们会经常使用prop去初始化子组件中的状态/data，然后去<strong>随心所欲</strong>操作这份数据。</p><p>有<strong>两种方式</strong>，可以实现以上目标，一是直接在data中使用prop赋予默认值，二是在created钩子中，有一个初始化状态方法 <code>initStatus(slefData)</code> 。</p><p>我<strong>更推荐后者</strong>，因为也许有一天我们会遇到<strong>父组件需要重置子组件内部状态</strong>的场景，比如<strong>换一题</strong>这样的功能。</p><p><strong>换一题功能的两种解决方案</strong></p><ol><li>深度监听试题数据，试题数据发生变化后，重新调用子组件内的 <code>iniSelfData</code> 方法，自己刷新自己。但实际上这是消耗性能，并且不合理的操作。</li><li>考虑到<strong>性能**</strong>，我们既不希望一个庞大的组件<strong>重新创建</strong>，又不想要<strong>上一题留下的冗余的状态</strong>。那么此时我们就可以拿到子组件实例，在获取到下一题数据后，用新的核心数据，去重新调用子组件内部 <code>initSatus(slefData)</code> 方法，达到<strong>优雅更新子组件状态</strong>的目的。这种操作子组件对外提供一个<strong>接口</strong> 即 <code>initStatus</code> 方法，<strong>将重置组件状态的控制权交给父组件</strong>，这样的设计更加<strong>合情合理</strong>。</li></ol></li><li><p>注意</p><p>我知道很多时候我们需要在 <code>created</code> 钩子函数中异步调接口获取数据初始化。</p><p>但是<strong>千万不要</strong>写出 <code>async created(){}</code> 这样的钩子函数，因为它会将整<strong>个创建函数变成异步函数</strong>。</p><p>随之带来的是内部的 <code>initStatus(slefData)</code> 函数也变成了异步，但实际上我们需要的是同步。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">async</span> created() &#123;</span><br><span class="line">  <span class="comment">// 初始化组件内部，一些由用户操作而改变的状态</span></span><br><span class="line">  initStatus()</span><br><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> requestFn()</span><br><span class="line">  handlerData(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">async</span> getData() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> requestFn()</span><br><span class="line">&#125;</span><br><span class="line">created() &#123;</span><br><span class="line">  <span class="comment">// 初始化组件内部，一些由用户操作而改变的状态</span></span><br><span class="line">  initStatus()</span><br><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> getData()</span><br><span class="line">  handlerData(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>技巧</p><p><strong>重置组件状态</strong>：<code>Object.assign(this.$data, this.$options.data())</code></p></li></ol><h2 id="v-show-与-v-if"><a href="#v-show-与-v-if" class="headerlink" title="v-show 与 v-if"></a>v-show 与 v-if</h2><h3 id="v-show-与-v-if-有什么区别"><a href="#v-show-与-v-if-有什么区别" class="headerlink" title="v-show 与 v-if 有什么区别"></a>v-show 与 v-if 有什么区别</h3><p>   v-show 控制元素是否 <code>display: none</code> ，从样式的角度控制元素隐藏显示</p><p>   v-if 控制元素的dom是否存在，通过生成、移除dom元素控制元素隐藏显示</p><h3 id="v-show-与-v-if-实战技巧"><a href="#v-show-与-v-if-实战技巧" class="headerlink" title="v-show 与 v-if 实战技巧"></a>v-show 与 v-if 实战技巧</h3><ol><li><p>状态控制</p><p>场景：填写表单</p><p>当我们填写表单时，我们可以使用v-show省去写一系列的回显逻辑。</p><p>但与此同时，场景中可能存在取消操作，重置为初始状态，由于v-show不会重置组件、元素状态，所以我们可以在v-show为true时，先保留一份数据的备份，当用户点击取消时，我们使用备份的数据将状态还原。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在vue开发中你不知道的黑科技。&lt;br&gt;
    
    </summary>
    
      <category term="技术积累" scheme="http://www.zbwblog.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="vue" scheme="http://www.zbwblog.com/tags/vue/"/>
    
  </entry>
  
</feed>
